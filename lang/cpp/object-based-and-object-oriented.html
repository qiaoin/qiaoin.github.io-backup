<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ 面向对象程序设计 | 在桥边</title>
    <meta name="description" content="偷得浮生半日闲">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.932e3e91.css" as="style"><link rel="preload" href="/assets/js/app.e709e50c.js" as="script"><link rel="preload" href="/assets/js/2.aed79e5e.js" as="script"><link rel="preload" href="/assets/js/38.6bded00e.js" as="script"><link rel="prefetch" href="/assets/js/10.ebac5325.js"><link rel="prefetch" href="/assets/js/11.7b2d672a.js"><link rel="prefetch" href="/assets/js/12.54ea6fcf.js"><link rel="prefetch" href="/assets/js/13.db76fbea.js"><link rel="prefetch" href="/assets/js/14.fa058a50.js"><link rel="prefetch" href="/assets/js/15.9a7abe23.js"><link rel="prefetch" href="/assets/js/16.c2552b58.js"><link rel="prefetch" href="/assets/js/17.92650ebe.js"><link rel="prefetch" href="/assets/js/18.1329c666.js"><link rel="prefetch" href="/assets/js/19.856e1bd6.js"><link rel="prefetch" href="/assets/js/20.ae008e83.js"><link rel="prefetch" href="/assets/js/21.bf7a5edb.js"><link rel="prefetch" href="/assets/js/22.9037bd3b.js"><link rel="prefetch" href="/assets/js/23.e2b0062c.js"><link rel="prefetch" href="/assets/js/24.7a5dc9db.js"><link rel="prefetch" href="/assets/js/25.51d89d5c.js"><link rel="prefetch" href="/assets/js/26.05fca636.js"><link rel="prefetch" href="/assets/js/27.53049f31.js"><link rel="prefetch" href="/assets/js/28.4ec6e500.js"><link rel="prefetch" href="/assets/js/29.3710e311.js"><link rel="prefetch" href="/assets/js/3.ce4ee92b.js"><link rel="prefetch" href="/assets/js/30.113a865b.js"><link rel="prefetch" href="/assets/js/31.32df48b4.js"><link rel="prefetch" href="/assets/js/32.6a9518d9.js"><link rel="prefetch" href="/assets/js/33.22fc30e7.js"><link rel="prefetch" href="/assets/js/34.dc080c4a.js"><link rel="prefetch" href="/assets/js/35.b9d1347c.js"><link rel="prefetch" href="/assets/js/36.012e0f79.js"><link rel="prefetch" href="/assets/js/37.52431a51.js"><link rel="prefetch" href="/assets/js/39.238f7705.js"><link rel="prefetch" href="/assets/js/4.796409a6.js"><link rel="prefetch" href="/assets/js/40.66e360c2.js"><link rel="prefetch" href="/assets/js/41.58481556.js"><link rel="prefetch" href="/assets/js/42.f8d39693.js"><link rel="prefetch" href="/assets/js/43.01ee4634.js"><link rel="prefetch" href="/assets/js/44.8481426f.js"><link rel="prefetch" href="/assets/js/45.aa1a9e0d.js"><link rel="prefetch" href="/assets/js/46.b9a5cb66.js"><link rel="prefetch" href="/assets/js/47.6963d786.js"><link rel="prefetch" href="/assets/js/48.b7224a2c.js"><link rel="prefetch" href="/assets/js/49.98dead63.js"><link rel="prefetch" href="/assets/js/5.ab04d8a1.js"><link rel="prefetch" href="/assets/js/50.d290680d.js"><link rel="prefetch" href="/assets/js/51.9317bcc1.js"><link rel="prefetch" href="/assets/js/52.56ac34b2.js"><link rel="prefetch" href="/assets/js/53.84b9fe5a.js"><link rel="prefetch" href="/assets/js/54.d134d158.js"><link rel="prefetch" href="/assets/js/55.09360f53.js"><link rel="prefetch" href="/assets/js/56.b88937d0.js"><link rel="prefetch" href="/assets/js/57.9781ff09.js"><link rel="prefetch" href="/assets/js/58.8632f2c4.js"><link rel="prefetch" href="/assets/js/59.0b61fe78.js"><link rel="prefetch" href="/assets/js/6.a8f689ef.js"><link rel="prefetch" href="/assets/js/60.b23c8bc9.js"><link rel="prefetch" href="/assets/js/61.99305fe8.js"><link rel="prefetch" href="/assets/js/62.b81b7ba9.js"><link rel="prefetch" href="/assets/js/63.27df456b.js"><link rel="prefetch" href="/assets/js/64.fa3ffb7b.js"><link rel="prefetch" href="/assets/js/65.c9d34a2b.js"><link rel="prefetch" href="/assets/js/66.2000d26a.js"><link rel="prefetch" href="/assets/js/67.aabdb00e.js"><link rel="prefetch" href="/assets/js/68.9ccf045a.js"><link rel="prefetch" href="/assets/js/69.0e0e4de8.js"><link rel="prefetch" href="/assets/js/7.83edc202.js"><link rel="prefetch" href="/assets/js/70.aef1292b.js"><link rel="prefetch" href="/assets/js/8.1d8b6d49.js"><link rel="prefetch" href="/assets/js/9.c0d52356.js">
    <link rel="stylesheet" href="/assets/css/0.styles.932e3e91.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">在桥边</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link router-link-active">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link router-link-active">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++ 基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/lang/cpp/object-based-and-object-oriented.html" class="active sidebar-link">C++ 面向对象程序设计</a></li><li><a href="/lang/cpp/object-model.html" class="sidebar-link">C++ 对象模型</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>STL</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/lang/cpp/stl-introduction.html" class="sidebar-link">C++ 标准库</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_0-0-目标"><a href="#_0-0-目标" class="header-anchor">#</a> 0.0 目标</h2> <ol><li>培养正规的、大气的编程习惯</li> <li>以良好的方式编写 C++ Class —— 基于对象（Object Based）
<ul><li>class without pointer members，以 Complex 为例子</li> <li>class with pointer members，以 String 为例子</li></ul></li> <li>学习 Classes 之间的关系 —— 面向对象（Object Oriented）
<ul><li>继承（inheritance）</li> <li>组合（composition）</li> <li>委托（delegation）</li></ul></li></ol> <blockquote><p>将 C++ 视为一个由相关语言组成的联邦</p></blockquote> <h2 id="术语"><a href="#术语" class="header-anchor">#</a> 术语</h2> <ul><li><strong>声明（declaration）</strong>：告诉编译器某个东西的名称和类型（type），但略去细节</li> <li><strong>定义（definition）</strong>：提供编译器一些声明时所遗漏的细节。对对象而言，定义是编译器为此对象拨发内存的地点；对 function 或 function template 而言，定义提供了代码本体；对 class 或 class template 而言，定义列出了它们的成员</li> <li><strong>初始化（initialization）</strong>：是“给予对象初值”的过程。对用户自定义类型的对象而言，初始化由构造函数执行。构造函数最好使用<strong>成员初值列</strong>（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同</li> <li><strong>default 构造函数</strong>：是一个可被调用而不带任何实参者，这样的构造函数要不没有，要不就是每个参数都有缺省值（默认值）</li> <li><strong>不明确行为（undefined）</strong>：例如，<code>i++ + ++i</code>，未定义行为，“有问题的，坏的行为，理论上什么事情都可能发生”，你无法稳定预估运行期会发生什么事</li> <li><strong>未指定行为（unspecified）</strong>：例如，参数的求职顺序，“你不能依赖的某个特定顺序，但其行为是良好定义的”</li> <li><strong>实现定义的行为（implementation）</strong>：例如，当一个 double 转换为 float 时，如果 double 变量的值不能精确表达在一个 float 中，那么选取下一个接近的离散值还是上一个接近的离散值是 implementation defined 的，实现定义的，“你可以在实现商的编译器文档中找到说明”</li></ul> <h2 id="header（头文件）中的防御式编程"><a href="#header（头文件）中的防御式编程" class="header-anchor">#</a> Header（头文件）中的防御式编程</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifndef</span> __LCOMPLEX__</span>
<span class="token macro property">#<span class="token directive keyword">define</span> __LCOMPLEX__</span>

<span class="token comment">/**
0. 前置声明（forward declarations）
*/</span>
<span class="token keyword">class</span> <span class="token class-name">ostream</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">lcomplex</span><span class="token punctuation">;</span>

lcomplex<span class="token operator">&amp;</span> <span class="token function">__doapl</span><span class="token punctuation">(</span>lcomplex<span class="token operator">*</span> ths<span class="token punctuation">,</span> <span class="token keyword">const</span> lcomplex<span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
1. 类声明（class declarations）
需要思考：
- 复数应该具有哪些数据，提供哪些函数，才能够满足使用复数的用户的需求
*/</span>
<span class="token keyword">class</span> <span class="token class-name">lcomplex</span>
<span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
2. 类定义（clss definition）
*/</span>
lcomplex<span class="token operator">::</span>function <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token macro property">#<span class="token directive keyword">endif</span>  </span><span class="token comment">// __LCOMPLEX__</span>
</code></pre></div><p>避免重复的 <code>#include</code> 头文件</p> <h2 id="inline-函数"><a href="#inline-函数" class="header-anchor">#</a> inline 函数</h2> <ul><li>函数如果太复杂，编译器就没法将其 <code>inline</code></li> <li>函数若在 <code>class body</code> 中定义完成，便自动成为 <code>inline</code> 候选者</li> <li><code>inline</code> 标识符或者在 <code>class body</code> 中定义的函数只是对编译器的建议而已，是否真的 <code>inline</code> 是由编译器来决定的</li></ul> <h2 id="构造函数-constructor"><a href="#构造函数-constructor" class="header-anchor">#</a> 构造函数 constructor</h2> <ul><li>函数名跟类名相同</li> <li>没有返回值类型，因为构造函数就是要来创建对象的，不用写</li> <li>可以拥有参数</li> <li>参数可以有默认值（其他函数的参数都可以有默认值）</li> <li>构造函数有特殊的语法：初始值列（initialization list）</li></ul> <p>构造函数使用初值列（initialization list）进行会更好。这种写法相较于在函数体中进行赋值（assignments）有什么好处呢？性能上更优，写法更符合 C++ 规范</p> <blockquote><p>参见《Effective C++》条款 4：确定对象被使用前已先被初始化</p></blockquote> <p>将对象初始化，C++ 在某些语境下是保证会进行初始化的，但在其他语境下却不保证。读取未初始化的值会导致<strong>不明确的行为（undefined behavior）</strong></p> <p><strong>最佳实践 Best Practice</strong>：永远在使用对象之前先将它初始化</p> <ul><li>对应无任何成员的内置类型，手动进行初始化，C++ 不保证初始化它们</li> <li>对于用户自定义类型，初始化责任落在构造函数身上，确保每一个构造函数都将对象的每一个成员初始化。构造函数最好使用<strong>成员初值列</strong>（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同</li></ul> <p>一个变量其数值的设定分两个阶段，1）初始化（对应构造函数 <code>:</code> 后的初值列），2）赋值（对应构造函数 <code>{}</code> 中的赋值操作）</p> <h3 id="区分赋值和初始化（assignment-and-initialization）"><a href="#区分赋值和初始化（assignment-and-initialization）" class="header-anchor">#</a> 区分赋值和初始化（assignment and initialization）</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">PhoneNumber</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">ABEntry</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> address<span class="token punctuation">,</span>
            <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">&gt;</span><span class="token operator">&amp;</span> phones<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string theName<span class="token punctuation">;</span>
    std<span class="token operator">::</span>string theAddress<span class="token punctuation">;</span>
    std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">&gt;</span> thePhones<span class="token punctuation">;</span>
    <span class="token keyword">int</span> numTimesConsulted<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> address<span class="token punctuation">,</span>
                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">&gt;</span><span class="token operator">&amp;</span> phones<span class="token punctuation">)</span>
<span class="token comment">// 编译器会为用户自定义类型（user-defined types）之成员变量自动调用 default 构造函数</span>
<span class="token punctuation">{</span>
    theName <span class="token operator">=</span> name<span class="token punctuation">;</span>      <span class="token comment">// 这些都是赋值（assignments），而非初始化（initializations）</span>
    theAddress <span class="token operator">=</span> address<span class="token punctuation">;</span>
    thePhones <span class="token operator">=</span> phones<span class="token punctuation">;</span>
    numTimesConsulted <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。在 <code>ABEntry</code> 构造函数内，<code>theName</code>、<code>theAddress</code> 和 <code>thePhones</code> 都不是被初始化，而是被赋值。初始化的发生时间更早，发生于这些成员的 default 构造函数被自动调用之时（比进入 <code>ABEntry</code> 构造函数本体的时间更早）</p> <p><code>ABEntry</code> 构造函数的一个较佳写法是，使用成员初值列（member initalization list）替换赋值动作：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> address<span class="token punctuation">,</span>
                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">&gt;</span><span class="token operator">&amp;</span> phones<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// 这些都是初始化（initializations）</span>
      <span class="token function">theAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">thePhones</span><span class="token punctuation">(</span>phones<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">numTimeConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><ul><li>基于赋值的版本，首先调用 <strong>default 构造函数</strong>为 <code>theName</code>、<code>theAddress</code> 和 <code>thePhones</code> 设初值，然后立刻再对它们<strong>赋新值</strong>。default 构造函数的一切行为因此浪费了</li> <li>基于成员初值列的版本，初值列针对各个成员变量设置实参，然后调用各个成员变量对应的<strong>拷贝构造函数</strong></li> <li>对于大多数类型而言，比起先调用 default 构造函数然后再调用 copy assignment 操作符，单只调用一次 copy 构造函数是比较高效的，有时甚至高效得多</li> <li>对于内置类型对象如 <code>numTimeConsulted</code>，其初始化和赋值的成本相同，但为了一致性最好也通过成员初值列来初始化</li> <li>如果成员变量是 <code>const</code> 或 <code>referenece</code>，它们就一定需要初值，不能被赋值</li> <li>总是在初值列中列出所有成员变量，以免还得记住哪些成员变量可以无需初值</li> <li>总是使用成员初值列</li> <li>C++ 的成员初始化次序：base classes 早于其 derived classses 被初始化，而 class 的成员变量总是已其声明次序被初始化。当在成员初值列中列出各个成员时，最好总是以其声明次序为次序</li></ul> <h3 id="不同编译单元内定义的-non-local-static-对象"><a href="#不同编译单元内定义的-non-local-static-对象" class="header-anchor">#</a> 不同编译单元内定义的 non-local static 对象</h3> <blockquote><p>参见《Effective C++》条款 4：确定对象被使用前已先被初始化</p></blockquote> <p><code>static</code> 对象包括 <code>global</code> 对象、定义于 <code>namespace</code> 作用域内的对象、在 <code>class</code> 内、在函数内、以及在 <code>file</code> 作用域内被声明为 <code>static</code> 的对象。函数内的 <code>static</code> 对象成为 <code>local static</code> 对象（因为它们对函数而言是 <code>local</code>)，其他 <code>static</code> 对象称为 <code>non-local static</code> 对象。程序结束时 <code>static</code> 对象会被自动销毁，也就是它们的析构函数会在 <code>main()</code> 结束时被自动调用</p> <p>编译单元基本上就是单一源码文件加上其所 <code>include</code> 的头文件。考虑两个不同的源码文件，每一个文件内含有至少一个 <code>non-local static</code> 对象，也就是说该对象是 <code>global</code> 或位于 <code>namespace</code> 作用域内，抑或是在 <code>class</code> 内或在 <code>file</code> 作用域内被声明为 <code>static</code>。真正的问题是：如果某编译单元内的某个 <code>non-local static</code> 对象的初始化动作使用了另一个编译单元内的某个 <code>non-local static</code> 对象，它所用到的这个对象可能尚未被初始化，因为 <strong>C++ 对“定于于不同编译单元内的 <code>non-local static</code> 对象”的初始化次序并无明确定义</strong></p> <p>解决办法：将每个 <code>non-local static</code> 对象搬到自己的专属函数内（该对象在此函数内被声明为 <code>static</code>），这些函数返回一个 <code>reference</code> 指向它所含的对象，然后用户调用这些函数，而不直接指涉这些对象。换句话说，<code>non-local static</code> 对象被 <code>local static</code> 对象替换了。这是单例模式的一个常见实现手法。</p> <p>这个手法的基础在于：<strong>C++ 保证，函数内的 <code>local static</code> 对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化</strong>。所以，以“函数调用”（返回一个 <code>reference</code> 指向 <code>local static</code> 对象）替换“直接访问 <code>non-local static</code> 对象”，就获得保证，保证了通过函数调用所获得的 <code>reference</code> 将指向一个历经初始化的对象</p> <h3 id="将构造函数放在-private-域，单例模式（singleton）"><a href="#将构造函数放在-private-域，单例模式（singleton）" class="header-anchor">#</a> 将构造函数放在 private 域，单例模式（Singleton）</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> A<span class="token operator">&amp;</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> A a<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> A<span class="token operator">&amp;</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// referen-returning 函数：第一行定义并初始化一个 local static 对象，第二行返回它</span>
A<span class="token operator">&amp;</span> A<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> A a<span class="token punctuation">;</span>  <span class="token comment">// 定义并初始化一个 local static 对象</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token comment">// 返回一个 reference 指向上述对象</span>
<span class="token punctuation">}</span>
</code></pre></div><p>之后使用 <code>A::getInstance().setup();</code> 进行调用</p> <h2 id="const"><a href="#const" class="header-anchor">#</a> const</h2> <blockquote><p>参见《Effective C++》条款 3:尽可能使用 const</p></blockquote> <p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。例如，有理数的 <code>operator*</code> 声明式：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Rational</span>
<span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>避免出现以下的使用错误：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Rational a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b <span class="token operator">=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编程时错误地将关系运算符 <code>==</code> 漏写为了赋值运算符 <code>=</code>。如果 <code>a</code>、<code>b</code> 是内置类型，这样的代码直截了当就是不合法。因此，我们在设计用户自定义类型时，应该避免无端地与内置类型不兼容，将 <code>operator*</code> 的返回值声明为 <code>const</code> 可以语法这个无意义的赋值动作</p> <h2 id="常量成员函数"><a href="#常量成员函数" class="header-anchor">#</a> 常量成员函数</h2> <p>在函数声明的参数列表右括号的后面添加 <code>const</code> 限制</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Complex</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">double</span> <span class="token function">real</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> <span class="token function">real</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">set_real</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> real<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>class 里面的函数分为两种：</p> <ol><li>会改变对象中包含的数据内容；</li> <li>不会改变对象中包含的数据内容，加上 <code>const</code> 修饰</li></ol> <p><strong>注意</strong>：</p> <ul><li>两个成员函数如果只是常量性（constness）不同（是否是常量成员函数），可以被重载（overloaded）</li> <li>C++ 以 by value 返回对象</li></ul> <p>成员函数如果是 <code>const</code> 意味着什么？<code>const</code> 成员函数不可以更改对象内任何 <code>non-static</code> 成员变量，也就是说不可以更改对象内的任何一个 bit。编译器强制实施 bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）</p> <p>对成员函数，该使用 <code>const</code> 修饰的，一定要加 <code>const</code> 修饰。否则，创建一个 <code>const</code> 常量实例，然后调用这个未使用 <code>const</code> 修饰的成员函数（就是告诉编译器说该函数可能会改变对象包含的数据内容），而实例使用 <code>const</code> 修饰（就是告诉编译器说这个实例是常量，其包含的数据内容是不能被改变的），这样就出现了矛盾，编译器就会报错</p> <h2 id="参数传递-pass-by-value-vs-pass-by-reference-to-const"><a href="#参数传递-pass-by-value-vs-pass-by-reference-to-const" class="header-anchor">#</a> 参数传递 pass by value vs. pass by reference (to const)</h2> <ul><li>pass by value：value 数据多大，函数进行参数传递的时候就把整个包都一起传过去，压入函数栈里面去</li> <li><strong>Best Practice</strong>：尽量不要 pass by value</li> <li>pass by reference，引用在底层的实现就相当于是指针，传引用就相当于传指针</li> <li><strong>Best Practice</strong>：参数传递尽量传引用 reference-to-const；传递引用又不希望函数会对值进行修改，可以传递 reference to const</li></ul> <h2 id="返回值传递-return-by-value-vs-return-by-reference-to-const"><a href="#返回值传递-return-by-value-vs-return-by-reference-to-const" class="header-anchor">#</a> 返回值传递 return by value vs. return by reference (to const)</h2> <ul><li>返回值传递尽量 return by reference</li></ul> <p>什么情况下可以 pass by reference？什么情况下可以 return by reference？</p> <p>一个函数的运算结果是放置在什么位置呢？</p> <ol><li>函数必须新创建一个地方来进行存放，函数需要返回新创建的这部分内容，但这部分内容的生命周期在函数调用返回时就结束了（函数调用栈释放了），为局部变量（local object），这时候就不能返回 reference，只能 return by value，在“<strong>临时对象</strong>”有示例；</li> <li>放置在已存在的位置上，就可以 return by reference</li></ol> <h3 id="临时对象"><a href="#临时对象" class="header-anchor">#</a> 临时对象</h3> <p>在类名后面直接加 <code>()</code>：<code>typename ()</code>，临时对象 temp object</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">inline</span> lcomplex
<span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> lcomplex<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> lcomplex<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">lcomplex</span><span class="token punctuation">(</span><span class="token function">real</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">real</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">imag</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">imag</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="友元-friend"><a href="#友元-friend" class="header-anchor">#</a> 友元 friend</h2> <p>自由取得 friend 的 private 成员</p> <p>相同 class 的各个 objects 互为友元</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">lcomplex</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">lcomplex</span><span class="token punctuation">(</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">re</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">im</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> lcomplex<span class="token operator">&amp;</span> param<span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> param<span class="token punctuation">.</span>re <span class="token operator">+</span> param<span class="token punctuation">.</span>im<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> re<span class="token punctuation">,</span> im<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="operator-overloading-操作符重载"><a href="#operator-overloading-操作符重载" class="header-anchor">#</a> operator overloading 操作符重载</h2> <blockquote><p>该选择成员函数，还是非成员函数？</p></blockquote> <h3 id="成员函数"><a href="#成员函数" class="header-anchor">#</a> 成员函数</h3> <p>所有的成员函数都含有一个隐藏的参数 this 指针，谁调用这个成员函数，谁就是 this</p> <p><img src="https://i.loli.net/2019/07/27/5d3c3d0f116f956799.png" alt="成员函数 this 指针"></p> <p>对于 return by reference 语法，传递者无需知道接收者是以 reference 形式接收的</p> <h3 id="非成员函数（全域函数），无-this-指针"><a href="#非成员函数（全域函数），无-this-指针" class="header-anchor">#</a> 非成员函数（全域函数），无 this 指针</h3> <h3 id="输入输出操作符重载"><a href="#输入输出操作符重载" class="header-anchor">#</a> 输入输出操作符重载</h3> <ul><li>只能写成非成员函数</li> <li>函数的第一个参数不能加 <code>const</code>，因为每次使用 <code>&lt;&lt;</code> 向 <code>os</code> 输出值的时候，<code>os</code> 的状态都在改变</li> <li>函数返回为 <code>ostream&amp;</code>，支持连续输出</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

ostream<span class="token operator">&amp;</span>
perator <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> lcomplex<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token string">'('</span> <span class="token operator">&lt;&lt;</span> <span class="token function">real</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">','</span> <span class="token operator">&lt;&lt;</span> <span class="token function">imag</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">')'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="cout"><a href="#cout" class="header-anchor">#</a> cout</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">_IO_ostream_withassign</span> <span class="token operator">:</span> <span class="token keyword">public</span> ostream
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">extern</span> _IO_ostream_withassign cout<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ostream</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> ios
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>c<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>c<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>设计一个类，怎么写才是更为规范的？</p> <ol><li>数据一定是放置在 private 里面的</li> <li>参数尽可能使用 reference 传递，并且考虑是否使用 const 修饰</li> <li>返回值尽可能使用 reference 传递</li> <li>需要使用 const 修饰的成员函数就一定要使用 const 进行修饰，不然可能编译器会报错</li> <li>构造函数使用 initialization list 进行初始化</li></ol> <h2 id="big-three-三个特殊函数"><a href="#big-three-三个特殊函数" class="header-anchor">#</a> Big Three 三个特殊函数</h2> <blockquote><p>参见《Effective C++》条款 5:了解 C++ 默默编写并调用哪些函数</p></blockquote> <ul><li>编译器会默认生成一套<strong>default 构造函数</strong>，<strong>拷贝构造函数</strong>和<strong>拷贝赋值函数</strong>，<strong>析构函数</strong>，都是 <code>public</code> 修饰</li> <li>编译器默认生成的会一个 bit 一个 bit 拷贝</li> <li>需要考虑编译器默认生成的函数是否够用和适用</li> <li>在 C++11 中，可以通过将<strong>拷贝构造函数</strong>和<strong>拷贝赋值函数</strong>定义为<strong>删除函数</strong>（delete function）来阻止拷贝，表明：我们虽然声明了它们，但不能以任何方式使用它们，直接在函数的参数列表后面加上 <code>=delete</code> 来指定删除函数</li> <li>class with pointer members 必须要有<strong>拷贝构造函数</strong>和<strong>拷贝赋值函数</strong>，还需要有<strong>析构函数</strong></li> <li>在<strong>拷贝赋值函数</strong>开始部分一定要检查是否是自我赋值（self assignment），保证正确性和高效率</li></ul> <blockquote><p>参见《Effective C++》条款 11:在 operator= 中处理“自我赋值”</p></blockquote> <ul><li><strong>Best Practice最佳实践</strong>：大多数类应该定义<strong>默认构造函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>和<strong>析构函数</strong>，无论是隐式地还是显式地</li></ul> <h3 id="拷贝构造函数和拷贝赋值函数"><a href="#拷贝构造函数和拷贝赋值函数" class="header-anchor">#</a> 拷贝构造函数和拷贝赋值函数</h3> <blockquote><p>参见《Effective C++》条款 12:复制对象时勿忘其每一个成分</p></blockquote> <p>为 derived class 编写拷贝构造函数和拷贝赋值函数，要确保（1）复制所有 local 成员变量，（2）调用所有 base classes 内的适当的 coping 函数</p> <ul><li>拷贝构造函数被用来“以同型对象初始化自我对象”</li> <li>拷贝赋值函数被用来“从另一个同型对象中拷贝其值到自我对象”</li> <li>如果一个新对象被定义，一定会有个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义，就不会有构造函数被调用，那么就是拷贝赋值函数被调用</li> <li>赋值符号 <code>=</code> 也可以用来调用拷贝构造函数</li> <li>拷贝构造函数定义了一个对象如何 pass-by-value（以值传递）</li> <li>以 by-value 传递用户自定义类型通常是个坏主意，pass-by-reference-to-const 往往是比较好的选择</li></ul> <h3 id="浅拷贝"><a href="#浅拷贝" class="header-anchor">#</a> 浅拷贝</h3> <h3 id="深拷贝"><a href="#深拷贝" class="header-anchor">#</a> 深拷贝</h3> <h2 id="何谓栈（stack），何谓堆（heap）"><a href="#何谓栈（stack），何谓堆（heap）" class="header-anchor">#</a> 何谓栈（stack），何谓堆（heap）</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/* ... */</span>

Complex <span class="token function">c3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    Complex <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Complex <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Complex<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Stack，是存在于某个作用域（scope）的一块内存空间（memory space）</li> <li>Heap，或谓 System heap，是指操作系统提供的一块全局内存空间，程序可动态分配（dynamic allocated）从中获得若个区块（blocks）</li></ul> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <ul><li><code>c1</code> 为 <strong>stack objects</strong>，其生命在作用域结束之际结束。这种作用域内的 object，又称为 <strong>auto object</strong>，因为它们会被自动清理，析构函数在作用域结束之际自动调用</li> <li><code>c2</code> 为 <strong>static local objects</strong>，其生命在作用域结束之后仍然存在，直到整个程序结束，即从被构造出来直到程序结束为止</li> <li><code>c3</code> 为 <strong>global objects</strong>，其生命在整个程序结束之后才结束。其作用域是整个程序</li> <li><code>p</code> 为 <strong>heap objects</strong>，其生命在它被 <strong>delete</strong> 之际结束</li></ul> <h2 id="new-和-delete"><a href="#new-和-delete" class="header-anchor">#</a> new 和 delete</h2> <blockquote><p>参见《Effective C++》条款 16:成对使用 new 和 delete 时要采用相同形式</p></blockquote> <h3 id="new"><a href="#new" class="header-anchor">#</a> new</h3> <p>（1）内存被分配出来（通过名为 <code>operator new</code> 的函数）；
（2）针对此内存会有一个（或多个）构造函数被调用</p> <p><img src="https://i.loli.net/2019/07/27/5d3c58574672522287.png" alt="new：先分配 memory，再调用构造函数"></p> <h3 id="delete"><a href="#delete" class="header-anchor">#</a> delete</h3> <p>（1）针对此内存会有一个（或更多）析构函数被调用；
（2）释放内存（通过名为 <code>operator delete</code> 的函数）</p> <p><img src="https://i.loli.net/2019/07/27/5d3c59aad32b276563.png" alt="delete：先调用析构函数，再释放 memory"></p> <p><code>delete</code> 的最大问题在于：即将被删除的内存之内究竟存有多少对象？这个问题决定了有多少个析构函数必须被调用起来。更简单的表述为：即将被删除的那个指针，所指的是单一对象还是对象数据？因为单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括“数组大小”的记录，以便 <code>delete</code> 知道需要调用多少次析构函数。单一对象的内存则不需要这笔记录。</p> <h3 id="单一对象的内存布局示意图"><a href="#单一对象的内存布局示意图" class="header-anchor">#</a> 单一对象的内存布局示意图</h3> <p><img src="https://i.loli.net/2019/09/13/4vZQDuVkdxBYCOL.png" alt="单一对象内存示意图"></p> <h3 id="对象数组的内存布局示意图"><a href="#对象数组的内存布局示意图" class="header-anchor">#</a> 对象数组的内存布局示意图</h3> <ul><li>array new 要搭配 array delete 使用，程序员需要告诉编译器需要 <code>delete</code> 的“数组大小”</li> <li>如果调用 <code>new</code> 时使用 <code>[]</code>，必须在对应调用 <code>delete</code> 时也使用 <code>[]</code></li> <li>如果调用 <code>new</code> 时没有使用 <code>[]</code>，一定不要在对应调用 <code>delete</code> 时使用 <code>[]</code></li></ul> <p><img src="https://i.loli.net/2019/07/28/5d3c78852fffc98769.png" alt="动态分配数组的内存示意图"></p> <p><img src="https://i.loli.net/2019/07/28/5d3c788542f7342619.png" alt="array new 要搭配 array delete 使用"></p> <h2 id="static"><a href="#static" class="header-anchor">#</a> static</h2> <ul><li>静态成员函数没有 this 指针，因此<strong>只能处理静态数据</strong></li> <li>调用 static 函数的方式有两种：
<ol><li>通过 object 调用</li> <li>通过 class name 调用</li></ol></li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">double</span> m_rate<span class="token punctuation">;</span>  <span class="token comment">// 声明</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">set_rate</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_rate <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> Account<span class="token operator">::</span>m_rate <span class="token operator">=</span> <span class="token number">8.0</span><span class="token punctuation">;</span>  <span class="token comment">// 定义，使得对应的变量获得内存</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Account<span class="token operator">::</span><span class="token function">set_rate</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Account a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">set_rate</span><span class="token punctuation">(</span><span class="token number">7.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利息 <code>m_rate</code> 称为 <strong>class 专属变量（class-specific variables）</strong>：</p> <ol><li>为了将变量的作用域（scope）限制于 class 内，必须让它成为 class 的一个成员（member）</li> <li>为了确保此变量至多只有一份实体，必须让它成为一个 static 成员</li></ol> <h2 id="类模版-class-template"><a href="#类模版-class-template" class="header-anchor">#</a> 类模版 class template</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>  <span class="token comment">// template、typename 都是关键字</span>
<span class="token keyword">class</span> <span class="token class-name">complex</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">complex</span><span class="token punctuation">(</span>T r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> T i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">re</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">im</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    complex<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> complex<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    T <span class="token function">real</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> re<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    T <span class="token function">imag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> im<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T re<span class="token punctuation">,</span> im<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    complex<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    complex<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c2<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="函数模版-function-template"><a href="#函数模版-function-template" class="header-anchor">#</a> 函数模版 function template</h2> <ul><li>编译器会做实参推导（argument deduction）</li> <li>C++ 标准库中的算法都是函数模版</li></ul> <h2 id="namespace"><a href="#namespace" class="header-anchor">#</a> namespace</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> <span class="token operator">&lt;</span><span class="token keyword">namespace</span><span class="token operator">-</span>name<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>using directive，<code>using namespace std;</code></li> <li>using declaration，<code>using std::cout;</code></li> <li>每一项都是用全名</li></ul> <h2 id="面向对象编程（面向对象设计）"><a href="#面向对象编程（面向对象设计）" class="header-anchor">#</a> 面向对象编程（面向对象设计）</h2> <p>类和类之间的关系：</p> <ol><li>继承 Inheritance</li> <li>组合 Composition</li> <li>委托 Delegation</li></ol> <h2 id="composition-复合，表示-has-a"><a href="#composition-复合，表示-has-a" class="header-anchor">#</a> Composition 复合，表示 has-a</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span> <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">queue</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    Sequence c<span class="token punctuation">;</span>  <span class="token comment">// 底层容器</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 以下完全利用 c 的操作函数完成</span>
    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    reference <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    reference <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// deque 是两端可进出，queue 是末端进前端出，先进先出</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>学会使用 UML 类图来表示</li> <li>Adapter 设计模式</li> <li>Container 和 Component 的生命期一致</li></ul> <h3 id="composition-关系下的构造和析构"><a href="#composition-关系下的构造和析构" class="header-anchor">#</a> Composition 关系下的构造和析构</h3> <p>编译器帮助完成：</p> <ul><li><strong>构造由内而外</strong>：Container 的构造函数首先调用 Component 的 <strong>default 构造函数</strong>，然后才执行自己</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Container<span class="token operator">::</span><span class="token function">Container</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>析构由外而内</strong>：Container 的析构函数函数首先执行自己，然后才调用 Component 的析构函数</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Container<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Container</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">~</span><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><h2 id="delegation-委托，composition-by-reference"><a href="#delegation-委托，composition-by-reference" class="header-anchor">#</a> Delegation 委托，Composition by reference</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// file String.hpp</span>
<span class="token keyword">class</span> <span class="token class-name">StringRep</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">String</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    String<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    StringRep<span class="token operator">*</span> rep<span class="token punctuation">;</span> <span class="token comment">// pimpl -&gt; pointer to implementation, handle &amp; body</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// file String.cpp</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&quot;String.hpp&quot;</span></span>
<span class="token keyword">namespace</span> <span class="token punctuation">{</span>
<span class="token keyword">class</span> <span class="token class-name">StringRep</span> <span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
    <span class="token function">StringRep</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">StringRep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> rep<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

String<span class="token operator">::</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre></div><ul><li>编译防火墙：Handle/Body，pImpl</li> <li>引用计数（reference counting）</li> <li>COW（copy on write），当共享的变量需要改变内容时，先完全拷贝一份，然后在得到的拷贝上进行相应的修改</li></ul> <h2 id="inheritance-继承，表示-is-a"><a href="#inheritance-继承，表示-is-a" class="header-anchor">#</a> Inheritance 继承，表示 is-a</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">_List_node_base</span>
<span class="token punctuation">{</span>
    _List_node_base<span class="token operator">*</span> _M_next<span class="token punctuation">;</span>
    _List_node_base<span class="token operator">*</span> _M_prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">_List_node</span>
  <span class="token operator">:</span> <span class="token keyword">public</span> _List_node_base
<span class="token punctuation">{</span>
    _Tp _M_data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>父类的数据会被子类完整继承</li></ul> <h3 id="inheritance（继承）关系下的构造和析构"><a href="#inheritance（继承）关系下的构造和析构" class="header-anchor">#</a> Inheritance（继承）关系下的构造和析构</h3> <blockquote><p>参见《Effective C++》条款 7:为多态基类声明 virtual 析构函数</p></blockquote> <ol><li>带多态性质的 base classes 应该声明一个 virtual 析构函数，这种 base classes 的设计目的是为了“通过 base class 接口处理 derived class 对象”。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数</li> <li>classes 的设计目的不是作为 base classes 使用，或不是为了具备多态性，就不该声明 virtual 析构函数。例如标准 string 和 STL 容器都不被设计作为 base classes 使用</li></ol> <ul><li><strong>构造由内而外</strong>：Derived 的构造函数首先调用 Base 的 default 构造函数，然后才执行自己</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Derived<span class="token operator">::</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><strong>析构由外而内</strong>：Derived 的析构函数首先执行自己，然后才调用 Base 的析构函数</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Derived<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="inheritance（继承）with-virtual-function（虚函数）"><a href="#inheritance（继承）with-virtual-function（虚函数）" class="header-anchor">#</a> Inheritance（继承）with virtual function（虚函数）</h3> <p>在继承的关系下，父类所有的东西都会被子类继承</p> <ol><li>数据可以被继承下来，占用内存的一部分</li> <li>函数也可以被继承下来，子类继承父类函数的调用权，子类可以调用父类的函数。那子类是否需要对继承的父类函数进行重新定义呢？</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 1. 纯虚函数，pure virtual</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2. 虚函数，impure virtual</span>
    <span class="token keyword">int</span> <span class="token function">objectID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment">// 3. 普通函数</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Ellipse</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol><li><strong>pure virtual</strong> 函数：希望子类一定要重新定义（override，覆写）的函数，现在父类中没有默认定义（可以有定义）</li> <li><strong>impure virtual</strong> 函数：希望子类重新定义（override，覆写）的函数，但父类中已提供了默认定义</li> <li><strong>non-virtual</strong> 函数：不希望子类重新定义（override，覆写）的函数</li></ol> <ul><li>创建子类对象</li> <li>通过子类对象调用父类方法</li> <li>Template method 设计模式</li></ul> <h3 id="inheritance-composition-关系下的构造和析构"><a href="#inheritance-composition-关系下的构造和析构" class="header-anchor">#</a> Inheritance+Composition 关系下的构造和析构</h3> <h3 id="delegation（委托）-inheritance（继承）"><a href="#delegation（委托）-inheritance（继承）" class="header-anchor">#</a> Delegation（委托）+Inheritance（继承）</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Subject</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> m_value<span class="token punctuation">;</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Observer<span class="token operator">*</span><span class="token operator">&gt;</span> m_views<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Observer<span class="token operator">*</span> obs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        m_views<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>obs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">set_val</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        m_value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m_views<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            m_views<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Observer</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Subject<span class="token operator">*</span> sub<span class="token punctuation">,</span> <span class="token keyword">int</span> vaule<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Observer 设计模式</li> <li>Composite 设计模式</li> <li>Prototype 设计模式：当下要去创建未来的 class 对象</li></ul> <p>参考书 Design Patterns Explained Simply</p> <h2 id="_1-0-目标"><a href="#_1-0-目标" class="header-anchor">#</a> 1.0 目标</h2> <ul><li>在 0.0 的基础课程所培养的正规、大器的编程素养上，继续探讨更多技术</li> <li>范型编程（Generic Programming）和面向对象编程（Object-Oriented Programming）虽然分属不同思维，但它们正是 C++ 的技术主线，本部分也讨论 template（模版）</li> <li>深入探索面向对象之继承关系（inheritance）所形成的对象模型（Object Model），包括隐藏于底层的 this 指针，vptr（虚指针），vtbl（虚表），virtual mechanism（虚机制），以及虚函数（virtual function）造成的 Polymorphism（多态）效果</li></ul> <h2 id="更多细节"><a href="#更多细节" class="header-anchor">#</a> 更多细节</h2> <ul><li>operator type() const;</li> <li>explicit complex(...) : initialization list {}</li> <li>pointer-like object</li> <li>function-like object</li> <li>Namespace</li> <li>template specialization</li> <li>Standard library</li> <li>variadic template (since C++11)--</li> <li>move ctor (since C++11)</li> <li>Rvalue reference (since C++11)</li> <li>auto (since C++11)--</li> <li>lambda (since C++11)</li> <li>range-base for loop (since C++11)--</li> <li>unordered containers (since C++11)</li> <li>...</li></ul> <h2 id="conversion-function-转换函数"><a href="#conversion-function-转换函数" class="header-anchor">#</a> conversion function 转换函数</h2> <ul><li>将当前对象转换为别样的对象</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Fraction</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Fraction</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> den<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">m_numerator</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_denominator</span><span class="token punctuation">(</span>den<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>m_numerator<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>m_denominator<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_numerator<span class="token punctuation">;</span>    <span class="token comment">// 分子</span>
    <span class="token keyword">int</span> m_denominator<span class="token punctuation">;</span>  <span class="token comment">// 分母</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    Fraction <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">+</span> f<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在标准库中有如下源码：</p> <p>vector bool</p> <h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="header-anchor">#</a> non-explicit-one-argument ctor</h2> <ul><li>one argument，只要一个实参就够了，另外可以有实参，提供对应的默认值即可</li> <li>two parameters, one argument</li> <li>关键字 explicit，“明白的，明确的”，用在构造函数的前面，禁止编译器执行非预期的类型转换</li> <li>将别种对象转换为当前对象</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Fraction</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Fraction</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> den<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">m_numerator</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_denominator</span><span class="token punctuation">(</span>den<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    Fraction <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Fraction<span class="token operator">&amp;</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Fraction</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>m_numerator <span class="token operator">+</span> f<span class="token punctuation">.</span>m_numerator<span class="token punctuation">,</span>
                        <span class="token keyword">this</span><span class="token operator">-&gt;</span>m_denominator <span class="token operator">+</span> f<span class="token punctuation">.</span>m_denominator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_numerator<span class="token punctuation">;</span>    <span class="token comment">// 分子</span>
    <span class="token keyword">int</span> m_denominator<span class="token punctuation">;</span>  <span class="token comment">// 分母</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    Fraction <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">+</span> f<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="header-anchor">#</a> pointer-like classes</h2> <blockquote><p>设计一个 class，让它的行为像一个指针</p></blockquote> <h3 id="shared-ptr-关于智能指针"><a href="#shared-ptr-关于智能指针" class="header-anchor">#</a> shared-ptr 关于智能指针</h3> <p><code>shared-ptr</code> 持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源。<code>shared-ptr</code> 允许指定所谓的“<strong>删除器（deleter）</strong>”，是一个函数或者函数对象（function object），当引用计数为 0 时便被调用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">shared_ptr</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>px<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> px<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span>    px<span class="token punctuation">;</span>
    <span class="token keyword">long</span><span class="token operator">*</span> pn<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> Foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
Foo <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>
sp<span class="token operator">-&gt;</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// px-&gt;method(), -&gt; 会一直作用下去</span>
</code></pre></div><ul><li>智能指针里面包含有普通指针</li> <li><code>*</code> <code>-&gt;</code> 运算符重载的写法确定，允许隐式转换至底层原始指针</li></ul> <blockquote><p>参见《Effective C++》条款 13:以对象管理资源</p></blockquote> <p>“以对象管理资源”的两个关键想法：</p> <ol><li><strong>获得资源后立刻放进管理对象内</strong>。实际上，“以资源管理对象”的观念常被称为“资源取得时机便是初始化时机”（Resource Acquisition Is Initialization，<strong>RAII</strong>），因为我们几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象，有时候获得的资源被拿来赋值某个管理对象（而非初始化）</li> <li><strong>管理对象运用析构函数确保资源被释放</strong>。不论控制流如何离开区块，一旦对象被销毁，其析构函数自然会被自动调用，于是资源被释放</li></ol> <h3 id="iter-关于迭代器"><a href="#iter-关于迭代器" class="header-anchor">#</a> iter 关于迭代器</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__list_node</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span><span class="token operator">*</span> prev<span class="token punctuation">;</span>
    <span class="token keyword">void</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
    T data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__list_iterator</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> __list_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">&gt;</span> self<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> Ptr pointer<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> Ref reference<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> __list_node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> link_type<span class="token punctuation">;</span>
    link_type node<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> node <span class="token operator">==</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> node <span class="token operator">!=</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    reference <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    pointer <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> node <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token keyword">return</span> tmp<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> node <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token keyword">return</span> tmp<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    list<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token operator">::</span>iterator ite<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>ite<span class="token punctuation">;</span>  <span class="token comment">// 获得一个 Foo object</span>
    ite<span class="token operator">-&gt;</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 意思是调用 Foo::method() 相当于 (*ite).method(); 相当于 (&amp;(*ite))-&gt;method();</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>关于迭代器的补充说明：</strong></p> <p>STL 迭代器以指针为根据塑模出来，所以迭代器的作用就像个 <code>T*</code> 指针。声明迭代器为 <code>const</code> 就像声明指针为 <code>const</code> 一样（即声明一个 <code>T* const</code> 指针，指针本身是常量，但指向的值可以改变），表示这个迭代器不得指向不同的东西，但它所指的东西的值是可以改动的。如果希望迭代器所指的东西不可被改动（即希望 STL 模拟一个 <code>const T*</code> 指针），需要使用 <code>const_iterator</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// iter 的作用像个 T* const</span>
<span class="token operator">*</span>iter <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 没问题，可以改变 iter 所指物</span>
<span class="token operator">++</span>iter<span class="token punctuation">;</span>      <span class="token comment">// 错误！iter 是 const</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>const_iterator cIter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cIter 的作用像个 const T*</span>
<span class="token operator">*</span>cIter <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 错误！*cIter 是 const</span>
<span class="token operator">++</span>cIter<span class="token punctuation">;</span>      <span class="token comment">// 没问题，可以改变 cIter</span>
</code></pre></div><h2 id="function-like-classes-所谓仿函数"><a href="#function-like-classes-所谓仿函数" class="header-anchor">#</a> function-like classes 所谓仿函数</h2> <blockquote><p>设计一个 class，让它的行为像一个函数</p></blockquote> <p><strong>思考</strong>：C++ 为什么要让一个 Class 像一个指针或者像一个函数？在什么情景下？有什么好处？</p> <ul><li><code>()</code> 小括号，函数调用操作符（function-call operator）</li> <li>任何一个东西如果它能够接受 <code>()</code> 操作符，我们就称这个东西是函数或者是一个像函数的东西</li> <li>函数对象，仿函数</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Pair</span>
<span class="token punctuation">{</span>
    T1 first<span class="token punctuation">;</span>
    T2 second<span class="token punctuation">;</span>
    <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">identity</span> <span class="token operator">:</span> <span class="token keyword">public</span> unary_function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">select1st</span> <span class="token operator">:</span> <span class="token keyword">public</span> unary_function<span class="token operator">&lt;</span>Pair<span class="token punctuation">,</span> <span class="token keyword">typename</span> Pair<span class="token operator">::</span>first_type<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">typename</span> Pair<span class="token operator">::</span>first_type<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Pair<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>first<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">select2nd</span> <span class="token operator">:</span> <span class="token keyword">public</span> unary_function<span class="token operator">&lt;</span>Pair<span class="token punctuation">,</span> <span class="token keyword">typename</span> Pair<span class="token operator">::</span>second_type<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">typename</span> Pair<span class="token operator">::</span>second_type<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Pair<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    select1st<span class="token operator">&lt;</span>Pair<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 1. 创建临时对象</span>
    <span class="token comment">// 2. 调用函数</span>
<span class="token punctuation">}</span>
</code></pre></div><p>标准库还有其他的仿函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">plus</span> <span class="token operator">:</span> <span class="token keyword">public</span> binary_function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token punctuation">,</span> T<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    T <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">minus</span> <span class="token operator">:</span> <span class="token keyword">public</span> binary_function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token punctuation">,</span> T<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    T <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">equal_to</span> <span class="token operator">:</span> <span class="token keyword">public</span> binary_function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">==</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">less</span> <span class="token operator">:</span> <span class="token keyword">public</span> binary_function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>unary 一元运算符，一个操作数</li> <li>binary 二元运算符，两个操作数</li></ul> <h3 id="标准库中，仿函数所使用的奇特的-base-classes"><a href="#标准库中，仿函数所使用的奇特的-base-classes" class="header-anchor">#</a> 标准库中，仿函数所使用的奇特的 base classes</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Arg</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">unary_function</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> Arg argument_type<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> Result result_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Arg1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Arg2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">binary_function</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> Arg1 first_argument_type<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> Arg2 second_argument_type<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> Result result_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>sizeof(xxx) 理论上是 0，实际是 1</li></ul> <h2 id="template-模版"><a href="#template-模版" class="header-anchor">#</a> template 模版</h2> <h3 id="class-template-类模版"><a href="#class-template-类模版" class="header-anchor">#</a> class template 类模版</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">complex</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">complex</span><span class="token punctuation">(</span>T r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> T i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">re</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">im</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    complex<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> complex<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    T <span class="token function">real</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> re<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    T <span class="token function">imag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> im<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T re<span class="token punctuation">,</span> im<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    complex<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">3.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    complex<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="function-template-函数模版"><a href="#function-template-函数模版" class="header-anchor">#</a> function template 函数模版</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">stone</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">stone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_w</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_h</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_weight</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">stone</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> we<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">_w</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_h</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_weight</span><span class="token punctuation">(</span>we<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> stone<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _weight <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>_weight<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _w<span class="token punctuation">,</span> _h<span class="token punctuation">,</span> _weight<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> b <span class="token operator">&lt;</span> a <span class="token operator">?</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">{</span>
    stone <span class="token function">r1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r3<span class="token punctuation">;</span>
    r3 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>编译器会对函数模版进行实参推导（argument deduction）</li> <li>根据实参推导的结构，T 是 <code>stone</code>，于是调用 <code>stone::operator&lt;</code></li></ul> <h3 id="member-template-成员模版"><a href="#member-template-成员模版" class="header-anchor">#</a> member template 成员模版</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">pair</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> T1 first_type<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> T2 seconde_type<span class="token punctuation">;</span>

    T1 first<span class="token punctuation">;</span>
    T2 second<span class="token punctuation">;</span>

    <span class="token function">pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">pair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 成员模版</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U2</span><span class="token operator">&gt;</span>
    <span class="token function">pair</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>U1<span class="token punctuation">,</span> U2<span class="token operator">&gt;</span><span class="token operator">&amp;</span> p<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>成员模版是 class template 里面的一个 member，然后它是一个模版，就称为 member template</li> <li>T1 T2是可以变换的，在 T1 T2 确定下来之后，里面的 U1 U2 也可以变化</li> <li>为了让构造函数更有弹性</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token operator">:</span> <span class="token keyword">public</span> __shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp1<span class="token operator">&gt;</span>
    <span class="token keyword">explicit</span> <span class="token function">shared_ptr</span><span class="token punctuation">(</span>_Tp1<span class="token operator">*</span> __p<span class="token punctuation">)</span>
      <span class="token operator">:</span> __shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Base1<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> Derived1<span class="token punctuation">;</span>  <span class="token comment">// up-cast</span>
shared_ptr<span class="token operator">&lt;</span>Base1<span class="token operator">&gt;</span> <span class="token function">sptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> Derived1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模拟 up-cast</span>
</code></pre></div><h2 id="specialization-模版特化"><a href="#specialization-模版特化" class="header-anchor">#</a> specialization 模版特化</h2> <ul><li>泛化 - 特化</li> <li>在设计了一个模版之后，需要局部特化</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 泛化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">hash</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 特化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>泛化称为全泛化（full）</li> <li>偏特化（partial specialization）</li></ul> <h2 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="header-anchor">#</a> partial specialization 偏特化</h2> <h3 id="个数上的偏"><a href="#个数上的偏" class="header-anchor">#</a> 个数上的偏</h3> <ul><li>bool 只需要占用一个 bit 上就可以了</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> Alloc<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Alloc<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> Alloc<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="范围上的偏"><a href="#范围上的偏" class="header-anchor">#</a> 范围上的偏</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 类型不为指针，就使用这一套代码</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">&lt;</span>U<span class="token operator">*</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 类型为指针，就使用这一套特化代码</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    C<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> obj1<span class="token punctuation">;</span>  <span class="token comment">// 使用第一套代码</span>
    C<span class="token operator">&lt;</span>string<span class="token operator">*</span><span class="token operator">&gt;</span> obj2<span class="token punctuation">;</span> <span class="token comment">// 使用第二套代码</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>接收任意类型</li> <li>接收指针类型，指针也是任意类型中的一种</li></ul> <h2 id="template-template-parameter-模版模版参数"><a href="#template-template-parameter-模版模版参数" class="header-anchor">#</a> template template parameter 模版模版参数</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span>
          <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
              <span class="token keyword">class</span> <span class="token class-name">Container</span>
        <span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">XCls</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Container<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">using</span> Lst <span class="token operator">=</span> List<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>

XCls<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> list<span class="token operator">&gt;</span> mylist1<span class="token punctuation">;</span>  <span class="token comment">// error</span>
XCls<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> Lst<span class="token operator">&gt;</span> mylist2<span class="token punctuation">;</span>   <span class="token comment">// success</span>
</code></pre></div><ul><li><code>template &lt;typename T&gt; class Container</code> 是一个模版的参数，其本身就是作为一个模版存在的</li> <li>在模版参数列表中，即尖括号中，<code>class</code> 和 <code>typename</code> 关键字是共通的。历史因素</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span>
          <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
              <span class="token keyword">class</span> <span class="token class-name">SmartPtr</span>
         <span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">XCls</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    SmartPtr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> sp<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">XCls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

XCls<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> shared_ptr<span class="token operator">&gt;</span> p1<span class="token punctuation">;</span>  <span class="token comment">// success</span>
XCls<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> unique_ptr<span class="token operator">&gt;</span> p2<span class="token punctuation">;</span>  <span class="token comment">// error</span>
XCls<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> weak_ptr<span class="token operator">&gt;</span>      p3<span class="token punctuation">;</span>  <span class="token comment">// error</span>
XCls<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token punctuation">,</span> auto_ptr<span class="token operator">&gt;</span>     p4<span class="token punctuation">;</span>  <span class="token comment">// success</span>
</code></pre></div><h3 id="这不是模版模版参数"><a href="#这不是模版模版参数" class="header-anchor">#</a> 这不是模版模版参数</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span> <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">stack</span>
<span class="token punctuation">{</span>
    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">protected</span><span class="token operator">:</span>
    Sequence c<span class="token punctuation">;</span>  <span class="token comment">// 底层容器</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s1<span class="token punctuation">;</span>
stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> s2<span class="token punctuation">;</span>
</code></pre></div><h2 id="c-标准库"><a href="#c-标准库" class="header-anchor">#</a> C++ 标准库</h2> <blockquote><p>库很重要，要熟用，掌握【侯捷另有一门讲 STL 标准库的视频课程】</p></blockquote> <p>确定当前编译器是否支持 C++11：macro __cplusplus</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> __cplusplus <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// - 对于支持 C++11 的编译器，输出为 201103，可能更高 C++20？</span>
    <span class="token comment">// - 对于 C++98 C++03，输出为 199711</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="c-11：variadic-template-数量不定的模版参数"><a href="#c-11：variadic-template-数量不定的模版参数" class="header-anchor">#</a> C++11：variadic template 数量不定的模版参数</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Types<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> firstArg<span class="token punctuation">,</span> <span class="token keyword">const</span> Types<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> firstArg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Inside variadic templates, sizeof...(args) yields the number of arguments</li> <li>一个和一包（pack）</li> <li>后面的一包可以拿来继承，组合</li> <li>标准库中大量使用这个语法</li></ul> <h2 id="c-11-auto"><a href="#c-11-auto" class="header-anchor">#</a> C++11: auto</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment">// 1. 第一种用法</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">::</span>iterator ite1<span class="token punctuation">;</span>
ite1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 第二种用法，编译器自动进行推断</span>
<span class="token keyword">auto</span> ite2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 错误写法</span>
<span class="token keyword">auto</span> ite3<span class="token punctuation">;</span>
ite3 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="c-11-range-base-for-loop"><a href="#c-11-range-base-for-loop" class="header-anchor">#</a> C++11: range-base for loop</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// pass by value</span>
    cout <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// pass by reference</span>
    elem <span class="token operator">*</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>reference 引用的底层实现就是 pointer 指针，只是表现的形式不同，编译器都是使用指针来实现引用的</li></ul> <h2 id="reference-引用"><a href="#reference-引用" class="header-anchor">#</a> Reference 引用</h2> <p>从内存的角度去看变量，变量有三种</p> <ul><li>值 value 本身</li> <li>指针，“指向”</li> <li>引用，“代表”，一定要设置初值，设置完成之后不能改变</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> r <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre></div><ul><li>sizeof(x) == sizeof(r)</li> <li>&amp;x = &amp;r</li> <li>reference 是一种漂亮的 pointer</li></ul> <p>编译器制造了一种假象，object 和其 reference 的大小相同，地址也相同</p> <h3 id="reference-的常见用途-参数传递"><a href="#reference-的常见用途-参数传递" class="header-anchor">#</a> reference 的常见用途 -- 参数传递</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span>Cls<span class="token operator">*</span> pobj<span class="token punctuation">)</span> <span class="token punctuation">{</span> pobj<span class="token operator">-&gt;</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span>Cls  obj<span class="token punctuation">)</span>  <span class="token punctuation">{</span> obj<span class="token punctuation">.</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func3</span><span class="token punctuation">(</span>Cls<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span>  <span class="token punctuation">{</span> obj<span class="token punctuation">.</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// func2 和 func3 调用端写法相同，很好</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Cls obj<span class="token punctuation">;</span>
<span class="token function">func1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接口不同，困扰</span>
<span class="token function">func2</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func3</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// func2 fun3 调用端接口相同，很好</span>
</code></pre></div><p>reference 通常不用于声明变量，而用于参数类型（parameters type）和返回类型（return type）的描述</p> <p>以下被认为是“same signature”（所以二者不能同时存在）：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">double</span> <span class="token function">imag</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> im<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment">// 传引用</span>
<span class="token keyword">double</span> <span class="token function">imag</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span>  im<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment">// 传值，二者签名相同，Ambiguity</span>
</code></pre></div><ul><li>成员函数加 const 是不是函数签名的一部分？是签名的一部分！</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/lang/cpp/object-model.html">
        C++ 对象模型
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e709e50c.js" defer></script><script src="/assets/js/2.aed79e5e.js" defer></script><script src="/assets/js/38.6bded00e.js" defer></script>
  </body>
</html>
