<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lab 2 - Memory Management | 在桥边</title>
    <meta name="description" content="偷得浮生半日闲">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.932e3e91.css" as="style"><link rel="preload" href="/assets/js/app.e709e50c.js" as="script"><link rel="preload" href="/assets/js/2.aed79e5e.js" as="script"><link rel="preload" href="/assets/js/31.32df48b4.js" as="script"><link rel="prefetch" href="/assets/js/10.ebac5325.js"><link rel="prefetch" href="/assets/js/11.7b2d672a.js"><link rel="prefetch" href="/assets/js/12.54ea6fcf.js"><link rel="prefetch" href="/assets/js/13.db76fbea.js"><link rel="prefetch" href="/assets/js/14.fa058a50.js"><link rel="prefetch" href="/assets/js/15.9a7abe23.js"><link rel="prefetch" href="/assets/js/16.c2552b58.js"><link rel="prefetch" href="/assets/js/17.92650ebe.js"><link rel="prefetch" href="/assets/js/18.1329c666.js"><link rel="prefetch" href="/assets/js/19.856e1bd6.js"><link rel="prefetch" href="/assets/js/20.ae008e83.js"><link rel="prefetch" href="/assets/js/21.bf7a5edb.js"><link rel="prefetch" href="/assets/js/22.9037bd3b.js"><link rel="prefetch" href="/assets/js/23.e2b0062c.js"><link rel="prefetch" href="/assets/js/24.7a5dc9db.js"><link rel="prefetch" href="/assets/js/25.51d89d5c.js"><link rel="prefetch" href="/assets/js/26.05fca636.js"><link rel="prefetch" href="/assets/js/27.53049f31.js"><link rel="prefetch" href="/assets/js/28.4ec6e500.js"><link rel="prefetch" href="/assets/js/29.3710e311.js"><link rel="prefetch" href="/assets/js/3.ce4ee92b.js"><link rel="prefetch" href="/assets/js/30.113a865b.js"><link rel="prefetch" href="/assets/js/32.6a9518d9.js"><link rel="prefetch" href="/assets/js/33.22fc30e7.js"><link rel="prefetch" href="/assets/js/34.dc080c4a.js"><link rel="prefetch" href="/assets/js/35.b9d1347c.js"><link rel="prefetch" href="/assets/js/36.012e0f79.js"><link rel="prefetch" href="/assets/js/37.52431a51.js"><link rel="prefetch" href="/assets/js/38.6bded00e.js"><link rel="prefetch" href="/assets/js/39.238f7705.js"><link rel="prefetch" href="/assets/js/4.796409a6.js"><link rel="prefetch" href="/assets/js/40.66e360c2.js"><link rel="prefetch" href="/assets/js/41.58481556.js"><link rel="prefetch" href="/assets/js/42.f8d39693.js"><link rel="prefetch" href="/assets/js/43.01ee4634.js"><link rel="prefetch" href="/assets/js/44.8481426f.js"><link rel="prefetch" href="/assets/js/45.aa1a9e0d.js"><link rel="prefetch" href="/assets/js/46.b9a5cb66.js"><link rel="prefetch" href="/assets/js/47.6963d786.js"><link rel="prefetch" href="/assets/js/48.b7224a2c.js"><link rel="prefetch" href="/assets/js/49.98dead63.js"><link rel="prefetch" href="/assets/js/5.ab04d8a1.js"><link rel="prefetch" href="/assets/js/50.d290680d.js"><link rel="prefetch" href="/assets/js/51.9317bcc1.js"><link rel="prefetch" href="/assets/js/52.56ac34b2.js"><link rel="prefetch" href="/assets/js/53.84b9fe5a.js"><link rel="prefetch" href="/assets/js/54.d134d158.js"><link rel="prefetch" href="/assets/js/55.09360f53.js"><link rel="prefetch" href="/assets/js/56.b88937d0.js"><link rel="prefetch" href="/assets/js/57.9781ff09.js"><link rel="prefetch" href="/assets/js/58.8632f2c4.js"><link rel="prefetch" href="/assets/js/59.0b61fe78.js"><link rel="prefetch" href="/assets/js/6.a8f689ef.js"><link rel="prefetch" href="/assets/js/60.b23c8bc9.js"><link rel="prefetch" href="/assets/js/61.99305fe8.js"><link rel="prefetch" href="/assets/js/62.b81b7ba9.js"><link rel="prefetch" href="/assets/js/63.27df456b.js"><link rel="prefetch" href="/assets/js/64.fa3ffb7b.js"><link rel="prefetch" href="/assets/js/65.c9d34a2b.js"><link rel="prefetch" href="/assets/js/66.2000d26a.js"><link rel="prefetch" href="/assets/js/67.aabdb00e.js"><link rel="prefetch" href="/assets/js/68.9ccf045a.js"><link rel="prefetch" href="/assets/js/69.0e0e4de8.js"><link rel="prefetch" href="/assets/js/7.83edc202.js"><link rel="prefetch" href="/assets/js/70.aef1292b.js"><link rel="prefetch" href="/assets/js/8.1d8b6d49.js"><link rel="prefetch" href="/assets/js/9.c0d52356.js">
    <link rel="stylesheet" href="/assets/css/0.styles.932e3e91.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">在桥边</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link router-link-active">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link router-link-active">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/basic/os/0-os-structures.html" class="sidebar-link">操作系统概述</a></li><li><a href="/basic/os/1-memory-management.html" class="sidebar-link">内存管理</a></li><li><a href="/basic/os/2-virtual-memory.html" class="sidebar-link">虚拟存储</a></li><li><a href="/basic/os/3-page-replacement-algo.html" class="sidebar-link">页面置换算法</a></li><li><a href="/basic/os/4-process-and-thread.html" class="sidebar-link">进程与线程</a></li><li><a href="/basic/os/5-scheduler.html" class="sidebar-link">CPU 调度</a></li><li><a href="/basic/os/6-synchronous-and-mutex.html" class="sidebar-link">同步互斥</a></li><li><a href="/basic/os/7-file-system.html" class="sidebar-link">文件系统</a></li><li><a href="/basic/os/8-io-subsystem.html" class="sidebar-link">IO 子系统</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MIT 6.828 实验</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/basic/os/mit-6.828-lab1.html" class="sidebar-link">Lab 1 - Booting a PC</a></li><li><a href="/basic/os/mit-6.828-lab2.html" class="active sidebar-link">Lab 2 - Memory Management</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="lab2-memory-management"><a href="#lab2-memory-management" class="header-anchor">#</a> <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab2/" target="_blank" rel="noopener noreferrer">Lab2: Memory Management<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h1> <p>In fact, in the next lab, we will map the entire bottom 256MB of the PC's physical address space, from physical addresses 0x00000000 through 0x0fffffff, to virtual addresses 0xf0000000 through 0xffffffff respectively. You should now see why JOS can only use the first 256MB of physical memory.</p> <blockquote><ul><li>【实验二于2019年4月11日开始，于4月13日完成 Part 1，初稿报告完成于4月xx日】</li> <li>【从学校毕业，正式参加工作后，就没有再看这部分内容了，现在重新拾起，2019年11月3日】</li> <li>【11月29日晚上和12月30日 做完lab2】</li></ul></blockquote> <p>内存管理（Memory management）主要包含两个部分：</p> <ul><li>1）<code>kernel</code> 的物理内存分配器（a physical memory allocator for the kernel），使用 4KB 的页大小，需要使用数据结构来记录哪些物理页面已被分配、哪些处于空闲，对于已分配的物理页面，记录该页面被多少个进程所共享；</li> <li>2）虚拟内存（virtual memory），将内核和用户程序使用的虚拟地址映射为物理地址。当指令执行时，x86 的硬件 MMU（内存管理单元）会进行虚拟地址向物理地址的映射。</li></ul> <p>与实验相关的源代码文件：</p> <ul><li><strong><code>inc/mmu.h</code></strong>：包含一些定义，需要好好看看</li> <li><strong><code>inc/memlayout.h</code></strong>：虚拟地址空间的布局，<code>PageInfo struct</code></li> <li><strong><code>kern/pmap.h[.c]</code></strong>：物理内存管理，读取 CMOS RAM 得到物理内存的大小（这部分代已经实现了，我们不需要关心 CMOS 工作的具体细节【透明与抽象】）</li> <li><strong><code>kern/kclock.h[.c]</code></strong>：manipulate the PC's battery-backed clock and CMOS RAM hardware, in which the BIOS records the amout of physical memory the PC contains</li></ul> <h2 id="part-1-physical-page-management"><a href="#part-1-physical-page-management" class="header-anchor">#</a> Part 1: Physical Page Management</h2> <p>操作系统需要维护好哪些物理内存单元是空闲的，哪些是正在被使用的。实验中，我们以页（page，4KB）为基本单位进行物理内存管理，因此可以使用 MMU 来完成地址映射并且为已分配的内存添加保护机制。</p> <p>实现物理内存（以页为基本单位）分配器，记录哪些页面是空闲的，使用一个链表来完成（链表节点表示 <code>struct PageInfo</code> 对象，其对应一个真实的物理内存页面）。</p> <div class="custom-block tip"><p class="custom-block-title">Exercise 1</p> <p>实现 <code>kern/pmap.c</code> 中的函数 <code>boot_alloc()</code>、<code>men_init()</code>、<code>page_init()</code>、<code>page_alloc()</code>、<code>page_free()</code>，使用 <code>check_page_free_list()</code> 和 <code>check_page_alloc()</code> 检查物理内存分配器的实现是否正确。Hint：添加 <code>assert()</code> 使用防御式编程，判断假设是否正确</p></div> <p>查看源文件，注意以下全局变量：</p> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br></div><pre class="language-c"><code><span class="token comment">// These variables are set by i386_detect_memory()</span>
size_t npages<span class="token punctuation">;</span>                  <span class="token comment">// Amount of physical memory (in pages)</span>
<span class="token keyword">static</span> size_t npages_basemem<span class="token punctuation">;</span>   <span class="token comment">// Amount of base memory (in pages)</span>

<span class="token comment">// These variables are set in mem_init()</span>
pde_t <span class="token operator">*</span>kern_pgdir<span class="token punctuation">;</span>                      <span class="token comment">// Kernel's initial page directory</span>
<span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span>pages<span class="token punctuation">;</span>                 <span class="token comment">// Physical page state array</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span>page_free_list<span class="token punctuation">;</span> <span class="token comment">// Free list of physical pages</span>
</code></pre></div><p>在 Part 1 中重点关注：</p> <ul><li><strong><code>npages</code></strong>：物理内存的总帧数，以页大小为单位（<code>PGSIZE</code> = 4096，4KB）。在 JOS 内核中维护了每个物理帧的空闲状态，每个物理帧对应一个 <code>struct PageInfo</code> 对象；</li> <li><strong><code>pages</code></strong>：表示物理内存的空闲状态（“占用”，“空闲”）的数组，数组的每一项对应物理内存中的一个 <code>PGSIZE</code> 大小的物理帧，因此数组总共有 <code>npages</code> 项；</li> <li><strong><code>page_free_list</code></strong>：全部的物理内存可以表示为 <code>npages</code> 个物理页帧（页帧大小为 4KB），每个物理页帧在内核的数据结构 <code>pages</code> 中对应数组的一项（one-to-one mapping），为 <code>struct PageInfo</code> 对象。在系统运行的过程中，执行程序、存储数据需要使用物理内存，对应的物理页帧的状态就会由之前的“空闲”变为“占用”。将所有空闲页帧对应的 <code>struct PageInfo</code> 对象串联为空闲链表，使用 <code>page_free_list</code> 表示链表头，每次要申请物理内存时就将当前 <code>page_free_list</code> 指向的 <code>struct PageInfo</code> 对象所对应的物理页帧给分配出去，并且将其从空闲链表移出，<code>page_free_list</code> 链表头向后移动。</li></ul> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br></div><pre class="language-c"><code><span class="token comment">/*
 * Each struct PageInfo stores metadata for one physical page.
 * Is it NOT the physical page itself, but there is a one-to-one
 * correspondence between physical pages and struct PageInfo's.
 * You can map a struct PageInfo * to the corresponding physical address
 * with page2pa() in kern/pmap.h.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token punctuation">{</span>
    <span class="token comment">// Next page on the free list.</span>
    <span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span>pp_link<span class="token punctuation">;</span>

    <span class="token comment">// pp_ref is the count of pointers (usually in page table entries)</span>
    <span class="token comment">// to this page, for pages allocated using page_alloc.</span>
    <span class="token comment">// Pages allocated at boot time using pmap.c's</span>
    <span class="token comment">// boot_alloc do not have valid reference count fields.</span>
    uint16_t pp_ref<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>如下示意图，<strong>灰色</strong>表示正被使用的物理内存，在内核数据结构 <code>pages</code> 中，正在被使用的物理页帧对应的数组项 <code>pp_link</code> 为 <code>NULL</code>，<code>pp_ref</code> 为 1（初始化为 1，记录对应物理页帧被引用的次数）。<strong>绿色</strong>表示空闲物理内存，在内核数据结构 <code>pages</code> 中，空闲物理页帧对应的数组项 <code>pp_ref</code> 为 0；各空闲物理页帧对应在 <code>pages</code> 数组中的项串联成<strong>单向链表</strong>，<code>page_free_list</code> 指向链表头，链表的最后一项 <code>pp_link</code> 为 <code>NULL</code>（用于判断空闲链表是否为空，out of free memory）。在下面的 <code>page_init()</code> 函数中会更细致地说明空闲链表的建立过程。</p> <div align="center"><img src="/mit-6.828-lab2-figures/pages-npages-free.png" width="606px" height="536px" alt="pages-npages-free"></div> <p>由 <a href="/basic/os/mit-6.828-lab1.html#part-3：the-kernel">Lab1 Part 3</a> 中分析得到，在 JOS 内核映像被加载进入内存之后，系统便立即跳转开始执行 <code>kern/entry.S</code> 的代码，开启页机制，设置好函数调用栈就开始执行 C 程序代码，即 <code>kern/init.c</code> 中的  <code>i386_init()</code> 函数。在 <code>i386_init()</code> 中调用 <code>mem_init()</code>，首先<strong>创建初始化时内核的数据结构</strong>：</p> <ol><li>分配物理内存，创建初始化的 page directory 并设置访问权限</li></ol> <div class="language-c extra-class"><div class="highlight-lines"><br><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-c"><code><span class="token comment">// create initial page directory.</span>
kern_pgdir <span class="token operator">=</span> <span class="token punctuation">(</span>pde_t <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">boot_alloc</span><span class="token punctuation">(</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Permissions: kernel R, user R</span>
kern_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>kern_pgdir<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_U <span class="token operator">|</span> PTE_P<span class="token punctuation">;</span>  <span class="token comment">// 待分析</span>
</code></pre></div><ol start="2"><li>分配物理内存，创建并初始化 pages 数组</li></ol> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted"> </div><br><br></div><pre class="language-c"><code><span class="token comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span>
<span class="token comment">// The kernel uses this array to keep track of physical pages: for</span>
<span class="token comment">// each physical page, there is a corresponding struct PageInfo in this</span>
<span class="token comment">// array.  'npages' is the number of physical pages in memory.</span>
pages <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">boot_alloc</span><span class="token punctuation">(</span>npages <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PageInfo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>pages<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> npages <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PageInfo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其后执行 <code>page_init()</code>，完成 <code>pages</code> 数组中各项的填充，建立好空闲链表，以 <code>page_free_list</code> 作为链表头：</p> <ol><li>物理页帧第 0 页正在被使用，用于实模式下的 IDT 和 BIOS；</li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">page_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 页面大小为 4KB</span>
    pages<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pp_ref <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    pages<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pp_link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>剩余的 base memory（或称为 low memory）空闲，物理内存地址区间 <code>[PGSIZE, npages_basemem * PGSIZE)</code>，640KB 处；</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> npages_basemem<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_link <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span>  <span class="token comment">// i.</span>
        page_free_list <span class="token operator">=</span> <span class="token operator">&amp;</span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// ii.</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>空闲链表是怎么建立的呢？初始化时，<code>page_free_list</code> 默认初始化为 <code>NULL</code>。有空闲物理页帧时，插入对应的 <code>struct PageInfo</code> 对象，</p> <ul><li>i. 将待插入的 <code>struct PageInfo</code> 对象的 <code>pp_link</code> 指向空闲链表首部，</li> <li>ii. 同时将已插入的 <code>struct PageInfo</code> 对象设置为空闲链表的新首部；</li></ul> <div align="center"><img src="/mit-6.828-lab2-figures/freelist-init.png" width="700px" height="190px" alt="freelist-init"></div> <ol start="3"><li>IO hole 正在被使用，保留它用（VGA Display，16-bit devices，expansion ROMs，BIOS ROM），物理内存地址区间 <code>[IOPHYSMEM, EXTPHYSMEM)</code>，640KB ~ 1MB，使用宏 <code>PGNUM</code> 根据物理地址得到对应的物理帧号；</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">PGNUM</span><span class="token punctuation">(</span>IOPHYSMEM<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">PGNUM</span><span class="token punctuation">(</span>EXTPHYSMEM<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_ref <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ol start="4"><li>Extended Memory，<code>bootloader</code> 将内核映像加载到 1MB 处，同时其链接地址为 <code>KERNBASE+1MB</code>，<code>kernel.img</code> 真实存放在物理内存中的页面需要保留，另外刚创建的内核数据结构 <code>kern_pgdir</code> 和 <code>pages</code> 也需要保留。这里调用 <code>boot_alloc(0)</code> 返回 <code>nextfree</code>，其保存着内核虚拟空间中能够使用的空闲空间的首地址，使用宏 <code>PADDR</code> 根据位于内核中的虚拟地址（以 <code>boot_alloc(0)</code> 返回的内核虚拟空间中空闲空间的首地址为参数）得到对应的物理地址；</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">PGNUM</span><span class="token punctuation">(</span>EXTPHYSMEM<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">PGNUM</span><span class="token punctuation">(</span><span class="token function">PADDR</span><span class="token punctuation">(</span><span class="token function">boot_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_ref <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ol start="5"><li>从内核虚拟地址 <code>nextfree</code> 对应的物理地址得到的帧号到 <code>npages</code> 全都是空闲帧；</li></ol> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">PGNUM</span><span class="token punctuation">(</span><span class="token function">PADDR</span><span class="token punctuation">(</span><span class="token function">boot_alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> npages<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pp_link <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span>  <span class="token comment">// i.</span>
        page_free_list <span class="token operator">=</span> <span class="token operator">&amp;</span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// ii. 同上面解释，构建空闲链表</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此就建立起了虚拟地址、空闲链表和物理地址的对应关系，之后均使用 <code>page_free_list</code> 来进行物理内存空间的分配和释放，并且维护 <code>pages</code> 数组以完成对物理页帧的空闲状态的跟踪：</p> <div align="center"><img src="/mit-6.828-lab2-figures/page-init.png" width="750px" height="507px" alt="page-init"></div> <p>接下来我们来看 <code>boot_alloc(uint32_t)</code> 函数应该如何实现，其作为真实的物理内存分配器，仅会在 JOS 设置虚拟存储系统时被调用（由 <code>mem_init()</code> 函数调用），在初始化完成之后，物理内存帧的分配与释放都是使用 <code>page_free_list</code> 来进行的：</p> <ul><li>1）如果 <code>n == 0</code>，返回 <code>nextfree</code>，其为内核虚拟空间中能够使用的空闲空间的首地址；</li> <li>2）如果 <code>n &gt; 0</code>，分配连续的物理帧，足够容纳下 <code>n</code> 个 byte，返回分配的物理帧的首地址，并将 <code>nextfree</code> 设置为空闲空间的首地址（注意对齐，需要是 <code>PGSIZE</code> 的整数倍）；</li> <li>3）如果物理内存不够用（out-of-memory），调用 <code>_painc()</code> 函数打印错误信息。</li></ul> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">boot_alloc</span><span class="token punctuation">(</span>uint32_t n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 处于 0xf0000000 之上的内核虚拟地址空间</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>nextfree<span class="token punctuation">;</span>  <span class="token comment">// virtual address of next byte of free memory</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>

    <span class="token comment">// Initialize nextfree if this is the first time.</span>
    <span class="token comment">// 'end' is a magic symbol automatically generated by the linker,</span>
    <span class="token comment">// which points to the end of the kernel's bss segment:</span>
    <span class="token comment">// the first virtual address that the linker did *not* assign</span>
    <span class="token comment">// to any kernel code or global variables.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextfree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">extern</span> <span class="token keyword">char</span> end<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        nextfree <span class="token operator">=</span> <span class="token function">ROUNDUP</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> end<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对 end 向上取 PGSIZE 的整数倍</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span>
    <span class="token comment">// nextfree.  Make sure nextfree is kept aligned</span>
    <span class="token comment">// to a multiple of PGSIZE.</span>
    <span class="token comment">//</span>
    <span class="token comment">// LAB 2: Your code here.</span>
    <span class="token comment">// 返回 next free page 的地址，虚拟地址</span>
    result <span class="token operator">=</span> nextfree<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// n 为无符号数，一定大于等于 0</span>
        nextfree <span class="token operator">=</span> <span class="token function">ROUNDUP</span><span class="token punctuation">(</span>nextfree <span class="token operator">+</span> n<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PGNUM</span><span class="token punctuation">(</span><span class="token function">PADDR</span><span class="token punctuation">(</span>nextfree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> npages<span class="token punctuation">)</span>  <span class="token comment">// 判断 out-of-memory</span>
            <span class="token function">_panic</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token string">&quot;boot_alloc %u bytes, out of memory&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>主要需要理解 <code>end</code> 是如何得到的？注释里写是链接器（linker）生成的，需要理解【TODO】</p> <p><code>page_alloc()</code> 作为后续的物理页帧分配器，每执行一次，仅仅分配<strong>一个</strong>空闲的物理页帧，并不会将 <code>pages</code> 数组中相应的 <code>struct PageInfo</code> 的 <code>pp_ref</code> 域加 1（对引用的计数需要调用方来维护），但一定要将 <code>pp_link</code> 域设置为 <code>NULL</code>（so <code>page_free</code> can check for double-free bugs）。为什么一定要将 <code>pp_link</code> 域设置为 <code>NULL</code> 呢？在初始化 <code>pages</code> 数组时，被占用物理页帧对应的数组项就是设置 <code>pp_link</code> 为 <code>NULL</code> 的。</p> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br></div><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span><span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token keyword">int</span> alloc_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Fill this function in</span>
    <span class="token comment">// return NULL if out of free memory</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page_free_list<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span>pp<span class="token punctuation">;</span>
    pp <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span>  <span class="token comment">// page_free_list 所在页的虚拟地址高于 KERNBASE？怎么确定</span>
                <span class="token comment">// page_free_list 指向 pages 数组的一项，pages 数组首地址高于 KERNBASE</span>
    page_free_list <span class="token operator">=</span> pp<span class="token operator">-&gt;</span>pp_link<span class="token punctuation">;</span>
    pp<span class="token operator">-&gt;</span>pp_link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">// page_free can check for double-free bugs</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>alloc_flags <span class="token operator">&amp;</span> ALLOC_ZERO<span class="token punctuation">)</span>
        <span class="token comment">// 设置了 ALLOC_ZERO 标记，将物理帧的内容全部用'\0'填充</span>
        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token function">page2kva</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> pp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div align="center"><img src="/mit-6.828-lab2-figures/page-alloc.png" width="642px" height="205px" alt="page-alloc"></div> <p>使用宏 <code>page2kva</code> 根据 <code>pages</code> 数组的数组项得到对应的位于内核空间的虚拟地址：</p> <ul><li>1）首先，得到该数组项对应的数组索引，执行指针相减 <code>pp - pages</code>；</li> <li>2）根据得到的数组索引就能够得到对应的物理地址，左移 12 位，<code>(pp - pages) &lt;&lt; PGSHIFT</code>；</li> <li>3）调用宏 <code>KADDR</code> 根据物理地址得到位于内核空间的虚拟地址。</li></ul> <p><code>page_free()</code> 实现比较简单，将 <code>pp</code> 指向当前空闲链表头 <code>page_free_list</code>，然后修改空闲链表头为新加入的空闲物理页帧标识 <code>pp</code> 即可，与 <code>page_init()</code> 的新建空闲链表是一样的。</p> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br></div><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">page_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span>pp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Fill this function in</span>
    <span class="token comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span>
    <span class="token comment">// pp-&gt;pp_link is not NULL.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token operator">-&gt;</span>pp_ref <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">_panic</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token string">&quot;PageInfo has ref = %08x&quot;</span><span class="token punctuation">,</span> pp<span class="token operator">-&gt;</span>pp_ref<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token operator">-&gt;</span>pp_link<span class="token punctuation">)</span>
        <span class="token function">_panic</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token string">&quot;PageInfo has link = %p&quot;</span><span class="token punctuation">,</span> pp<span class="token operator">-&gt;</span>pp_link<span class="token punctuation">)</span><span class="token punctuation">;</span>

    pp<span class="token operator">-&gt;</span>pp_link <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span>
    page_free_list <span class="token operator">=</span> pp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此，我们使用内核数据结构 <code>pages</code> 数组跟踪记录实际物理内存页帧的使用情况，数组项与物理页帧一一对应，物理页帧空闲，则对应数组项 <code>pp_ref</code> 域为 0、<code>pp_link</code> 域指向下一个空闲物理页帧对应的数组项；物理页帧正在被使用，则对应数组项 <code>pp_ref</code> 为引用计数（记录该物理页帧被引用的次数，Part 2 会更详细解释）、<code>pp_link</code> 指向 <code>NULL</code>。<code>page_free_list</code> 指向空闲链表头，在 <code>page_init()</code> 初始化完成之后，接下来的物理内存管理都经由 <code>page_*()</code> 系列函数（不会再去显式调用 <code>boot_alloc()</code>）。</p> <p>在 <code>mem_init()</code> 函数完成 <code>page_init()</code> 初始化之后，会调用 <code>check_page_free_list()</code> 和 <code>check_page_alloc()</code> 检查实现实现是否正确，当 <code>QEMU</code> 打印以下字样说明完成 Exercise 1：</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">check_page_free_list() succeeded!
check_page_alloc() succeeded!
</span></code></pre></div><p>在 <code>check_page_free_list()</code> 函数中的这块代码实现很有意思：【TODO 之后可以好好分析一下】</p> <div class="language-c extra-class"><pre class="language-c"><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span>only_low_memory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Move pages with lower addresses first in the free</span>
        <span class="token comment">// list, since entry_pgdir does not map all pages.</span>
        <span class="token comment">// 这段代码写的很巧妙，pdx_limit 以 4MB 为界限</span>
        <span class="token comment">// above 4MB =&gt; pagetype = 1</span>
        <span class="token comment">// below 4MB =&gt; pagetype = 0</span>
        <span class="token comment">// 实现了 page_free_list 从 4MB 之下开始，一直到最低的地址，</span>
        <span class="token comment">// 再转向到最高物理地址的空闲帧，然后到 4MB 结束</span>
        <span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span>pp1<span class="token punctuation">,</span> <span class="token operator">*</span>pp2<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">PageInfo</span> <span class="token operator">*</span><span class="token operator">*</span>tp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">&amp;</span>pp1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pp2 <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>pp <span class="token operator">=</span> page_free_list<span class="token punctuation">;</span> pp<span class="token punctuation">;</span> pp <span class="token operator">=</span> pp<span class="token operator">-&gt;</span>pp_link<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> pagetype <span class="token operator">=</span> <span class="token function">PDX</span><span class="token punctuation">(</span><span class="token function">page2pa</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> pdx_limit<span class="token punctuation">;</span>
            <span class="token operator">*</span>tp<span class="token punctuation">[</span>pagetype<span class="token punctuation">]</span> <span class="token operator">=</span> pp<span class="token punctuation">;</span>
            tp<span class="token punctuation">[</span>pagetype<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>pp<span class="token operator">-&gt;</span>pp_link<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token operator">*</span>tp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>tp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pp2<span class="token punctuation">;</span>
        page_free_list <span class="token operator">=</span> pp1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="part-2-virtual-memory"><a href="#part-2-virtual-memory" class="header-anchor">#</a> Part 2: Virtual Memory</h2> <p>x86 保护模式下的内存管理架构——分段（segmentation）和分页（paging）</p> <div class="custom-block tip"><p class="custom-block-title">Exercise 2</p> <p>阅读 Intel 80386 Reference Manual 第 5 章和第 6 章，主要阅读 5.2 节和 6.4 节，基于页的地址翻译（page translation）和基于页的保护机制（page-based protection），同时建议略读段机制（segmentation）的章节。虽然 JOS 主要使用页机制来完成虚拟存储和保护，但对于 x86 处理器段地址翻译（segment translation）和基于段的保护机制（segment-based protection）不能被禁用（为了向下兼容），因此需要对段机制和页机制（<strong>重点</strong>）都有所了解。</p></div> <h3 id="虚拟地址、线性地址和物理地址"><a href="#虚拟地址、线性地址和物理地址" class="header-anchor">#</a> 虚拟地址、线性地址和物理地址</h3> <p>x86 中虚拟地址（virtual address，或称逻辑地址，logical address）由段基址和段内偏移两部分组成（<code>segment:offset</code>），经由段机制映射得到线性地址（linear address）。在页机制开启之前，线性地址与物理地址（physics address）相等；当开启页机制之后，线性地址还需经页机制映射得到物理地址。CPU 根据物理地址经由总线（bus）访问物理内存。</p> <div align="center"><img src="/mit-6.828-lab2-figures/va-la-pa.png" width="691px" height="171px" alt="va-la-pa"></div> <p>在 <code>boot/boot.S</code> 中，我们在初始化全局描述符表 <code>GDT</code>（Global Descriptor Table）时，将所有的段基址（<code>base</code>）设置为 0，段的长度限制（<code>limit</code>）设置为 <code>0xffffffff</code>（宏 <code>SEG_NULL</code> 和 <code>SEG</code> 定义在 <code>inc/mmu.h</code> 中）</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code># Bootstrap GDT
<span class="token directive keyword">.p2align</span> <span class="token decimalnumber string">2</span>                            # force <span class="token decimalnumber string">4</span> byte alignment
gdt:
  SEG_NULL                            # null seg
  SEG(STA_X|STA_R, <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span>xffffffff)   # code seg
  SEG(STA_W, <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span>xffffffff)         # data seg
</code></pre></div><p>这样就类似关闭了（disabled）段机制，因此虚拟地址（<code>segment:offset</code>）中的段基址（<code>segment</code>）没有了作用（其被设置为 0），线性地址与虚拟地址中的偏移（<code>offset</code>）相等。在 Lab3 中我们会使用段机制去设置特权级（privilege levels），但是对于内存地址映射，我们可以暂时忽略掉段机制，在本实验中重点关注页机制。</p> <p>在 <a href="/basic/os/mit-6.828-lab1.html#part-3：the-kernel">Lab1 的 Part 3</a>， <code>kern/entrypgdir.c</code> 中创建了 <code>4MB*2</code> 的虚拟地址到物理地址的映射关系（在本实验的 Part 1 中已经给出了映射关系图）：</p> <ul><li>将 <code>0xf0000000 ~ 0xf0400000</code> 虚拟地址翻译为对应的物理地址 <code>0x00000000 ~ 0x00400000</code></li> <li>将 <code>0x00000000 ~ 0x00400000</code> 虚拟地址翻译为对应的物理地址 <code>0x00000000 ~ 0x00400000</code></li></ul> <p>使得 JOS 内核能够在 <code>0xf0100000</code> 链接地址处运行，<code>bootloader</code> 将内核映像实际载入的物理地址为 <code>0x00100000</code>（刚好在 BIOS ROM 的上面，从 <code>1MB</code> 地址往上）。<code>kern/entrypgdir.c</code> 中的 <code>entry_pgdir</code> 仅映射了 <code>4MB</code> 的内存空间，在本实验中我们将映射第一个 <code>256MB</code> 的物理内存到虚拟地址 <code>0xf0000000</code> 处，还会映射虚拟地址空间中的很多其他区域。</p> <ul><li>将 <code>0xf0000000 ~ 0xffffffff</code> 虚拟地址翻译为对应的物理地址 <code>0x00000000 ~ 0x0fffffff</code></li></ul> <div class="custom-block tip"><p class="custom-block-title">Exercise 3</p> <p>同时按下 <code>Ctrl-a c</code> 进入 QEMU monitor 模式（再次按 <code>Ctrl-a c</code> 回到串口控制台），使用 <code>xp</code> 命令直接查看物理内存。</p></div> <p>在 <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html" target="_blank" rel="noopener noreferrer">6.828 lab tools guide<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的 QEMU 部分，列出了一些有用的命令：</p> <ul><li><strong><code>xp/Nx paddr</code></strong>：打印出物理地址 <code>paddr</code> 开始的 <code>N</code> 个字的十六进制表示，与 GDB 命令 <code>x/Nx paddr</code> 相同。使用 QEMU monitor 的 <code>xp</code> 命令和 GDB 的 <code>x</code> 命令检查匹配的虚拟地址和物理地址处的数据是否相同。</li></ul> <p>在 <code>kern/entry.S</code> 中启动分页机制后，虚拟地址和物理地址映射关系已经建立好（<code>4MB</code>），这里我们选择查看 JOS 内核加载地址 <code>0x00100000</code> 和链接地址 <code>0xf0100000</code>，在 QEMU monitor 中查看物理地址 <code>0x00100000</code> 处的数据，在 GDB 中查看虚拟地址 <code>0xf0100000</code> 处的数据：</p> <ul><li>1）重新启动 QEMU 和 GDB；</li> <li>2）在 GDB 中设置断点，<code>b *0xf010039</code>，查看 <code>obj/kern/kernel.asm</code> 找到调用 <code>i386_init()</code> 函数时的链接地址；</li> <li>3）执行 <code>c(ontinue)</code>，在 GDB 中 <code>x/10x 0xf0100000</code> 打印，在 QEMU monitor 中 <code>xp/10x 0x00100000</code> 打印，得到相同的结果。</li></ul> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">(gdb) x/10x 0xf0100000
0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002 0x00000000 0xe4524ffe 0x7205c766
0xf0100010 &lt;entry+4&gt;:           0x34000004 0x3000b812 0x220f0011 0xc0200fd8
0xf0100020 &lt;entry+20&gt;:          0x0100010d 0xc0220f80

(qemu) xp/10x 0x00100000
0000000000100000:               0x1badb002 0x00000000 0xe4524ffe 0x7205c766
0000000000100010:               0x34000004 0x3000b812 0x220f0011 0xc0200fd8
0000000000100020:               0x0100010d 0xc0220f80
</span></code></pre></div><hr> <ul><li><strong><code>info registers</code></strong>：打印机器的内部寄存器状态，包含段选择子（segment selector）的隐藏部分、GDT 和 LDT、IDT，以及任务寄存器（task register）。这样从（可见的）段寄存器中得到选择子，以选择子作为索引去 GDT 中找对应表项，就得到了段的隐藏信息（<code>base+limit</code> 等）。</li></ul> <p>打印运行到断点 <code>b *0xf010039</code> 处的寄存器状态：</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]
</span></code></pre></div><ul><li>1）<code>CS =0008</code>：代码段选择子的可见部分为 <code>0x0008</code>，就能够得到需要去 GDT 中查找（<code>0x0008 &amp; 4 = 0</code>），并且当前特权级（CPL，current privilege level）为 0（段选择子的 <code>0x0008 &amp; 3 = 0</code>）。高 13 位为 <code>index</code> 去索引 GDT 或 LDT，第 14 位为 <code>0</code> 就表示 GDT，最低两位表示特权级（0/1/2/3）；</li> <li>2）<code>00000000</code>：段基址（<code>base</code>）。线性地址 = 逻辑地址 + 段基址；</li> <li>3）<code>ffffffff</code>：段的长度（<code>limit</code>），段内偏移要小于段的长度，否则报告异常；</li> <li>4）<code>00cf9a00</code>：段的各个标志位（raw flags）；</li> <li>5）<code>DPL=0</code>：段的特权级，只有在特权级 0 下执行的代码才能够加载这个段；</li> <li>6）<code>CS32</code>：32 位的代码段。对于其他的寄存器这个位置的表示不同，DS 表示代码段（data segments），DS 寄存器（DS register）为代码段选择子，二者要分清楚，另外还有 LDT（local descriptor table）局部描述符表；</li> <li>7）<code>[-R-]</code>：只读。</li></ul> <hr> <ul><li><strong><code>info mem</code></strong>：已建立好映射关系的虚拟地址空间及其对应的访问权限：</li></ul> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">0000000000000000-0000000000400000 0000000000400000 -r-
00000000f0000000-00000000f0400000 0000000000400000 -rw
</span></code></pre></div><ul><li>1）从 <code>0000000000000000-0000000000400000</code> 的 <code>0000000000400000</code> bytes 的虚拟内存已经建立好映射关系，只读（read）</li> <li>2）从 <code>00000000f0000000-00000000f0400000</code> 的 <code>0000000000400000</code> bytes 的虚拟内存已经建立好映射关系，可读可写（read&amp;write）</li></ul> <p>与 <code>kern/entrypgdir.c</code> 中建立的映射关系相一致。</p> <hr> <ul><li><strong><code>info pg</code></strong>：打印当前二级页表结构（page directory 10 位 + page table 10 位），偏移（<code>offset</code>）位于低 12 位。一个 PDE（page directory entry）对应同一组里的多个 PTE（page table entry）：</li></ul> <div align="center"><img src="/mit-6.828-lab2-figures/page-table-hardware.png" width="654px" height="624px" alt="page-table-hardware"></div> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">VPN range     Entry         Flags        Physical page
[00000-003ff]  PDE[000]     ----A----P
  [00000-000ff]  PTE[000-0ff] --------WP 00000-000ff
  [00100-00100]  PTE[100]     ----A---WP 00100
  [00101-003ff]  PTE[101-3ff] --------WP 00101-003ff
[f0000-f03ff]  PDE[3c0]     ----A---WP
  [f0000-f00ff]  PTE[000-0ff] --------WP 00000-000ff
  [f0100-f0100]  PTE[100]     ----A---WP 00100
  [f0101-f03ff]  PTE[101-3ff] --------WP 00101-003ff
</span></code></pre></div><p>包含两个 PDE，虚拟地址范围为 <code>0x00000000 ~ 0x003fffff</code> 和 <code>0xf0000000 ~ 0xf03fffff</code>，两个 PED 都是 <code>present</code> 和 <code>accessed</code>（TODO 这个具体表示什么，上面截图里也有），可使用 <code>PED[xxx]</code> 中的 <code>xxx</code> 来进行索引，即 page directory 的第 <code>0x000</code> 项和第 <code>0x3c0</code> 项，分别对应一个 page table，QEMU 将每个 page table 中当前已经完成映射的 <code>1024</code> 项 PTE 对应的标识（Flags）和物理页帧号都标识出来了。</p> <p><strong>一旦我们进入保护模式，在 CPU 上执行的指令就都是使用虚拟地址了</strong>。所有的地址引用（memory references）都会被解释为虚拟地址，并且由硬件 MMU 负责执行地址转换——在使能页机制之前，虚拟地址转化为线性地址，线性地址与物理地址相等；当使能页机制之后，虚拟地址转化为线性地址，线性地址需在页机制的作用下转换为物理地址。因此，在 C 语言中使用的所有指针都是虚拟地址（all pointers in C are virtual addresses）。</p> <p>JOS 内核有时候使用的物理地址，有时候使用的是虚拟地址，为了方便，做如下规定：</p> <ul><li><code>T*</code>：虚拟地址（各种常见数据类型的指针，例如 <code>uint32_t</code>）</li> <li><code>uintptr_t</code>：虚拟地址</li> <li><code>physaddr_t</code>：物理地址</li></ul> <p>JOS 内核首先将 <code>uintptr_t</code> 强制类型转化（<code>casting</code>）为一个指针类型，然后就能够执行解引用（<code>dereference</code>）。“将 <code>physaddr_t</code> 强制类型转化为指针类型然后解引用”，这样的做法并不明智，因为 MMU 会将这个物理地址误认为是虚拟地址，然后进行地址映射，这并不是我们希望得到的内存地址。</p> <p>这里我们再次提一下 Part 1 中使用过的两个宏 <code>KADDR(pa)</code> 和 <code>PADDR(va)</code>：</p> <ul><li><code>KADDR(pa)</code>：将实际的物理地址转换为内核空间的虚拟地址；</li> <li><code>PADDR(va)</code>：将内核数据结构对应的内核空间的虚拟地址转换为实际的物理地址。</li></ul> <div class="custom-block warning"><p class="custom-block-title">Question 1</p> <p>假设以下的 JOS 内核代码片段是正确的，那么变量 <code>x</code> 是什么类型，<code>uintptr_t</code> 还是 <code>physaddr_t</code>？</p> <div class="language-c extra-class"><pre class="language-c"><code>    mystery_t x<span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> value <span class="token operator">=</span> <span class="token function">return_a_pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> <span class="token punctuation">(</span>mystery_t<span class="token punctuation">)</span> value<span class="token punctuation">;</span>
</code></pre></div></div> <p>虚拟地址 <code>uintptr_t</code></p> <h3 id="引用计数（reference-count）"><a href="#引用计数（reference-count）" class="header-anchor">#</a> 引用计数（reference count）</h3> <p>多个虚拟页面可能使用到相同的物理页帧，这样我们就需要在该物理页帧对应的 <code>struct PageInfo</code> 结构体的 <code>pp_ref</code> 域中保存当前物理页帧的引用计数。并且在 PDE 和 PTE 中的每一个项也对应有引用位标记（TODO 待考察）。当该物理页帧的引用计数减少为 0 时（说明现在该物理页帧未被使用），可以释放，标记为空闲物理页帧（free frame），即调用 <code>page_free(pp)</code>。</p> <p>另外需要注意的是，如 <a href="/basic/os/mit-6.828-lab2.html#part-1-physical-page-management">Part 1</a> <code>page_alloc</code> 的实现，分配空闲的物理页帧给调用者（<code>caller</code>），其 <code>struct PageInfo</code> 结构体的引用计数为 0，<code>pp_ref</code> 域里引用计数的增加或减少是由调用者来维护的。</p> <h3 id="页表管理（page-table-management）"><a href="#页表管理（page-table-management）" class="header-anchor">#</a> 页表管理（page table management）</h3> <div class="custom-block tip"><p class="custom-block-title">Exercise 4</p> <p>实现 <code>kern/pmap.c</code> 中的函数 <code>pgdir_walk()</code>、<code>boot_map_region()</code>、<code>page_lookup()</code>、<code>page_remove()</code>、<code>page_insert()</code>，从 <code>mem_init()</code> 中调用 <code>check_page()</code> 来检查页表管理的实现是否正确</p></div> <h2 id="part-3：kernel-address-space"><a href="#part-3：kernel-address-space" class="header-anchor">#</a> Part 3：Kernel Address Space</h2> <p>操作系统</p> <div class="custom-block tip"><p class="custom-block-title">Exercise 5</p> <p>使用 QEMU 和 GDB 单步跟踪 JOS，执行到 <code>movl %eax, %cr0</code>，检查在执行这条汇编指令前后内存单元 <code>0x00100000</code> 和 <code>0xf0100000</code> 的内容</p></div> <div class="custom-block warning"><p class="custom-block-title">Question 2</p> <p>填充</p></div> <div class="custom-block warning"><p class="custom-block-title">Question 3</p> <p>填充</p></div> <div class="custom-block warning"><p class="custom-block-title">Question 4</p> <p>填充</p></div> <div class="custom-block warning"><p class="custom-block-title">Question 5</p> <p>填充</p></div> <div class="custom-block warning"><p class="custom-block-title">Question 6</p> <p>填充</p></div> <div class="custom-block danger"><p class="custom-block-title">Challenge! 1</p> <p>We cons</p></div> <div class="custom-block danger"><p class="custom-block-title">Challenge! 2</p> <p>We cons</p></div> <div class="custom-block danger"><p class="custom-block-title">Challenge! 3</p> <p>We cons</p></div> <div class="custom-block danger"><p class="custom-block-title">Challenge! 4</p> <p>We cons</p></div> <div class="custom-block danger"><p class="custom-block-title">Challenge! 5</p> <p>We cons</p></div> <p>主要参考：</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/basic/os/mit-6.828-lab1.html" class="prev">
        Lab 1 - Booting a PC
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e709e50c.js" defer></script><script src="/assets/js/2.aed79e5e.js" defer></script><script src="/assets/js/31.32df48b4.js" defer></script>
  </body>
</html>
