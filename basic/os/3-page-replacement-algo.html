<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>页面置换算法 | 在桥边</title>
    <meta name="description" content="偷得浮生半日闲">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.932e3e91.css" as="style"><link rel="preload" href="/assets/js/app.e709e50c.js" as="script"><link rel="preload" href="/assets/js/2.aed79e5e.js" as="script"><link rel="preload" href="/assets/js/23.e2b0062c.js" as="script"><link rel="prefetch" href="/assets/js/10.ebac5325.js"><link rel="prefetch" href="/assets/js/11.7b2d672a.js"><link rel="prefetch" href="/assets/js/12.54ea6fcf.js"><link rel="prefetch" href="/assets/js/13.db76fbea.js"><link rel="prefetch" href="/assets/js/14.fa058a50.js"><link rel="prefetch" href="/assets/js/15.9a7abe23.js"><link rel="prefetch" href="/assets/js/16.c2552b58.js"><link rel="prefetch" href="/assets/js/17.92650ebe.js"><link rel="prefetch" href="/assets/js/18.1329c666.js"><link rel="prefetch" href="/assets/js/19.856e1bd6.js"><link rel="prefetch" href="/assets/js/20.ae008e83.js"><link rel="prefetch" href="/assets/js/21.bf7a5edb.js"><link rel="prefetch" href="/assets/js/22.9037bd3b.js"><link rel="prefetch" href="/assets/js/24.7a5dc9db.js"><link rel="prefetch" href="/assets/js/25.51d89d5c.js"><link rel="prefetch" href="/assets/js/26.05fca636.js"><link rel="prefetch" href="/assets/js/27.53049f31.js"><link rel="prefetch" href="/assets/js/28.4ec6e500.js"><link rel="prefetch" href="/assets/js/29.3710e311.js"><link rel="prefetch" href="/assets/js/3.ce4ee92b.js"><link rel="prefetch" href="/assets/js/30.113a865b.js"><link rel="prefetch" href="/assets/js/31.32df48b4.js"><link rel="prefetch" href="/assets/js/32.6a9518d9.js"><link rel="prefetch" href="/assets/js/33.22fc30e7.js"><link rel="prefetch" href="/assets/js/34.dc080c4a.js"><link rel="prefetch" href="/assets/js/35.b9d1347c.js"><link rel="prefetch" href="/assets/js/36.012e0f79.js"><link rel="prefetch" href="/assets/js/37.52431a51.js"><link rel="prefetch" href="/assets/js/38.6bded00e.js"><link rel="prefetch" href="/assets/js/39.238f7705.js"><link rel="prefetch" href="/assets/js/4.796409a6.js"><link rel="prefetch" href="/assets/js/40.66e360c2.js"><link rel="prefetch" href="/assets/js/41.58481556.js"><link rel="prefetch" href="/assets/js/42.f8d39693.js"><link rel="prefetch" href="/assets/js/43.01ee4634.js"><link rel="prefetch" href="/assets/js/44.8481426f.js"><link rel="prefetch" href="/assets/js/45.aa1a9e0d.js"><link rel="prefetch" href="/assets/js/46.b9a5cb66.js"><link rel="prefetch" href="/assets/js/47.6963d786.js"><link rel="prefetch" href="/assets/js/48.b7224a2c.js"><link rel="prefetch" href="/assets/js/49.98dead63.js"><link rel="prefetch" href="/assets/js/5.ab04d8a1.js"><link rel="prefetch" href="/assets/js/50.d290680d.js"><link rel="prefetch" href="/assets/js/51.9317bcc1.js"><link rel="prefetch" href="/assets/js/52.56ac34b2.js"><link rel="prefetch" href="/assets/js/53.84b9fe5a.js"><link rel="prefetch" href="/assets/js/54.d134d158.js"><link rel="prefetch" href="/assets/js/55.09360f53.js"><link rel="prefetch" href="/assets/js/56.b88937d0.js"><link rel="prefetch" href="/assets/js/57.9781ff09.js"><link rel="prefetch" href="/assets/js/58.8632f2c4.js"><link rel="prefetch" href="/assets/js/59.0b61fe78.js"><link rel="prefetch" href="/assets/js/6.a8f689ef.js"><link rel="prefetch" href="/assets/js/60.b23c8bc9.js"><link rel="prefetch" href="/assets/js/61.99305fe8.js"><link rel="prefetch" href="/assets/js/62.b81b7ba9.js"><link rel="prefetch" href="/assets/js/63.27df456b.js"><link rel="prefetch" href="/assets/js/64.fa3ffb7b.js"><link rel="prefetch" href="/assets/js/65.c9d34a2b.js"><link rel="prefetch" href="/assets/js/66.2000d26a.js"><link rel="prefetch" href="/assets/js/67.aabdb00e.js"><link rel="prefetch" href="/assets/js/68.9ccf045a.js"><link rel="prefetch" href="/assets/js/69.0e0e4de8.js"><link rel="prefetch" href="/assets/js/7.83edc202.js"><link rel="prefetch" href="/assets/js/70.aef1292b.js"><link rel="prefetch" href="/assets/js/8.1d8b6d49.js"><link rel="prefetch" href="/assets/js/9.c0d52356.js">
    <link rel="stylesheet" href="/assets/css/0.styles.932e3e91.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">在桥边</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link router-link-active">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link router-link-active">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/basic/os/0-os-structures.html" class="sidebar-link">操作系统概述</a></li><li><a href="/basic/os/1-memory-management.html" class="sidebar-link">内存管理</a></li><li><a href="/basic/os/2-virtual-memory.html" class="sidebar-link">虚拟存储</a></li><li><a href="/basic/os/3-page-replacement-algo.html" class="active sidebar-link">页面置换算法</a></li><li><a href="/basic/os/4-process-and-thread.html" class="sidebar-link">进程与线程</a></li><li><a href="/basic/os/5-scheduler.html" class="sidebar-link">CPU 调度</a></li><li><a href="/basic/os/6-synchronous-and-mutex.html" class="sidebar-link">同步互斥</a></li><li><a href="/basic/os/7-file-system.html" class="sidebar-link">文件系统</a></li><li><a href="/basic/os/8-io-subsystem.html" class="sidebar-link">IO 子系统</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>MIT 6.828 实验</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/basic/os/mit-6.828-lab1.html" class="sidebar-link">Lab 1 - Booting a PC</a></li><li><a href="/basic/os/mit-6.828-lab2.html" class="sidebar-link">Lab 2 - Memory Management</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="页面置换算法"><a href="#页面置换算法" class="header-anchor">#</a> 页面置换算法</h1> <h2 id="页面置换算法的概念"><a href="#页面置换算法的概念" class="header-anchor">#</a> 页面置换算法的概念</h2> <p><strong>功能：</strong></p> <p>当出现缺页异常，需调入新页面而物理内存已满时，置换算法选择被置换的物理页帧</p> <p><strong>设计目标：</strong></p> <p>尽可能减少页帧的调入调出次数，把未来不再访问或短期内不访问的页帧调出。这与实际运行的程序对存储的访问特征有很大关系（通用置换算法考虑可能得进程访问存储的特征）。如何对未来的情况进行估计呢？</p> <p>有一些物理页帧被锁定（Frame Locking，pin memory），不能够从物理内存中换出到外存中去</p> <ul><li>描述必须常驻内存的逻辑页面</li> <li>操作系统的关键部分</li> <li>要求响应速度的代码和数据</li> <li>页表项中的锁定标志位（lock bit）</li></ul> <p><strong>置换算法的评价方法：</strong></p> <p>记录进程访问内存的页面轨迹，模拟页面置换行为，记录产生缺页的次数。更少的缺页，对应更好的性能</p> <p><strong>页面置换算法的分类：</strong></p> <ol><li>局部页面置换算法：置换页面的选择范围仅限于当前进程占用的物理页面内
<ul><li>最优算法、先进先出算法、最近最久未使用算法</li> <li>时钟算法、最不常用算法（两种对最近最久未使用算法的近似）</li></ul></li> <li>全局页面置换算法：置换页面的选择范围是所有可换出的物理页面
<ul><li>工作集算法、缺页率算法</li></ul></li></ol> <h2 id="局部置换算法"><a href="#局部置换算法" class="header-anchor">#</a> 局部置换算法</h2> <p>假定给一个进程的物理页面数已经确定好了</p> <h3 id="最优页面置换算法（opt，optimal）"><a href="#最优页面置换算法（opt，optimal）" class="header-anchor">#</a> 最优页面置换算法（OPT，optimal）</h3> <ul><li>思路：置换在未来最长时间不访问的页面</li> <li>实现：缺页时，计算内存中每个逻辑页面的下一次访问时间，选择未来最长时间不放问的页面</li> <li>特征
<ul><li>缺页最少，是理想情况</li> <li>实际系统中无法实现</li> <li>无法预知每个页面在下次访问前的等待时间</li> <li>可以作为其他置换算法的性能评价依据：在模拟器上运行某个程序并记录每一次的页面访问情况；在第二次运行时使用最优页面置换算法</li></ul></li></ul> <h3 id="先进先出算法（fifo，first-in-first-out）"><a href="#先进先出算法（fifo，first-in-first-out）" class="header-anchor">#</a> 先进先出算法（FIFO，First-In First-Out）</h3> <ul><li>思路：选择在内存驻留时间最长的页面进行置换</li> <li>实现
<ul><li>维护一个记录所有位于内存中的逻辑页面链表</li> <li>链表元素按驻留内存的时间排序，链首最长，链尾最短</li> <li>出现缺页时，选择链首页面进行置换，新页面加到链尾</li></ul></li> <li>特征
<ul><li>实现简单</li> <li>性能较差，调出的页面可能是经常访问的</li> <li>进程分配物理页面数增加时，缺页并不一定减少（Belady 现象）</li> <li>很少单独使用</li></ul></li></ul> <h3 id="最近最久未使用算法（lru，least-recently-used）"><a href="#最近最久未使用算法（lru，least-recently-used）" class="header-anchor">#</a> 最近最久未使用算法（LRU，Least Recently Used）</h3> <ul><li>思路：选择最长时间没有被引用的页面进行置换，如某些页面长时间未被访问，则它们在将来还可能会长时间不会被访问</li> <li>实现
<ul><li>缺页时，计算内存中每个逻辑页面的上一次访问时间</li> <li>选择上一次使用到当前时间最长的页面</li></ul></li> <li>特征：最优置换算法的一种近似，开销较大</li> <li>可能实现：
<ul><li><ol><li>页面链表：系统维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，链表尾节点是最久未使用的页面</li></ol> <ul><li>访问内存时，找到相应页面，并把它移到链表首部</li> <li>缺页时，置换链表尾节点的页面</li></ul></li> <li><ol start="2"><li>活动页面栈</li></ol> <ul><li>访问页面时，将此页号压入栈顶，并栈内相同的页号抽出</li> <li>缺页时，置换栈底的页面</li></ul></li></ul></li></ul> <h3 id="时钟页面置换算法（clock）"><a href="#时钟页面置换算法（clock）" class="header-anchor">#</a> 时钟页面置换算法（Clock）</h3> <ul><li>思路
<ul><li>仅对页面的访问情况进行大致排序</li></ul></li> <li>数据结构
<ul><li>在页表项中增加访问位，描述页面在过去一段时间内的访问情况</li> <li>各页面组织成环形链表</li> <li>指针指向最先调入的页面</li></ul></li> <li>算法
<ul><li>访问页面时，在页表项记录页面的访问情况</li> <li>缺页时，从指针处开始顺序查找未被访问的页面进行置换（FIFO）</li></ul></li> <li>特征
<ul><li>时钟算法是 LRU 和 FIFO 的折中（对过去的访问情况有考虑，但是置换的就是过去一段时间没有访问的页面，不是去找最久未访问的页面）</li></ul></li> <li>实现：
<ul><li>页面装入内存时，访问位初始化为 0；访问页面（读/写）时，访问位设置为 1</li> <li>缺页时，从指针当前位置顺序检查环形链表，若访问位为 0，则置换该页；若访问位为 1，则将访问位设置为 0（表示从当前时间点重新开始记录是否访问），并指针移动到下一个页面，直到找到可置换的页面</li></ul></li> <li>改进的时钟算法
<ul><li>思路是减少修改页的缺页处理开销（如果有修改，则跳过这一页不做置换，系统定期将修改过的页写到外存中去）。</li> <li>在页表项中增加修改位，并在访问时进行相应修改（如果是读操作，仅修改访问位为1，修改位为 0；如果是写操作，修改位和访问位同时置 1）</li> <li>缺页时，修改页表项标志位，以跳过有修改的页面</li></ul></li></ul> <div align="center"><img src="/os-notes-figures/dirty-reference-bit.png" width="187px" height="141px" alt="dirty-reference-bit"></div> <h3 id="最不常用算法（lfu，least-frequently-used）"><a href="#最不常用算法（lfu，least-frequently-used）" class="header-anchor">#</a> 最不常用算法（LFU，Least Frequently Used）</h3> <ul><li>思路：缺页时，置换访问次数最少的页面</li> <li>实现
<ul><li>每个页面设置一个访问计数</li> <li>访问页面时，访问计数加 1</li> <li>缺页时，置换计数最小的页面</li></ul></li> <li>特征
<ul><li>算法开销大</li> <li>开始时频繁使用，但以后不使用的页面很难置换（解决办法：计数定期做衰减右移）</li></ul></li> <li>LRU 和 LFU 的区别
<ul><li>LRU 关注多久未访问，时间越短越好</li> <li>LFU 关注访问次数，次数越多越好</li></ul></li></ul> <h3 id="belady-现象"><a href="#belady-现象" class="header-anchor">#</a> Belady 现象</h3> <ul><li>现象：采用 FIFO 等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象</li> <li>原因：FIFO 算法的置换特征与进程访问内存的动态特征相矛盾，被算法置换出去的页面并不一定是进程近期不会访问的</li> <li>思考：哪些置换算法没有 Belady 现象？LRU 没有 Belady 现象</li> <li>时钟/改进的时钟页面置换算法是否有 Belady 现象？</li> <li>为什么 LRU 页面置换算法没有 Belady 现象？【思考？】</li></ul> <h3 id="比较"><a href="#比较" class="header-anchor">#</a> 比较</h3> <ul><li>LRU 算法和 FIFO 本质上都是先进先出的思想
<ul><li>LRU 根据页面的最近访问时间排序</li> <li>LRU 在执行过程中需要动态地调整顺序</li> <li>FIFO 依据页面进入内存的时间排序</li> <li>FIFO 的页面进入时间是固定不变的</li></ul></li> <li>LRU 可退化为 FIFO
<ul><li>如页面进入内存后就没有被访问，最近访问时间和进入内存时间是相同的（视频流）</li></ul></li> <li>LRU 算法性能好，但系统开销较大</li> <li>FIFO 算法系统开销较小，会发生 Belady 现象</li> <li>Clock 算法是 LRU 和 FIFO 的折中
<ul><li>访问页面时，不动态调整页面在链表中的顺序，仅做标记</li> <li>缺页时，再把它移动到链表末尾</li></ul></li> <li>对于未访问过的页面，Clock 和 LRU 算法的表现一样好</li> <li>对于被访问过的页面，Clock 算法不能记录准确访问顺序，而 LRU 算法可以</li></ul> <h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="header-anchor">#</a> 全局页面置换算法</h2> <p>局部页面置换算法没有考虑进程访存的差异性（因为分配给进程的页面数确定了）</p> <p>全局置换算法为进程分配可变数目的物理页面。那分给各个进程多少物理页面呢？进程在不同阶段的内存需求是变化的，这样再不同的阶段分配给进程的内存也需要有所变化。全局置换算法需要确定分配给进程的物理页面数</p> <h3 id="cpu-利用率与并发进程数的关系"><a href="#cpu-利用率与并发进程数的关系" class="header-anchor">#</a> CPU 利用率与并发进程数的关系</h3> <p>CPU 利用率与并发进程数存在相互促进和制约的关系</p> <ul><li>进程数少时，提高并发进程数，可提高 CPU 利用率</li> <li>并发进程导致内存访问增加</li> <li>并发进程的内存访问会降低访存的局部性特征</li> <li>局部性特征的下载会导致缺页率上升和 CPU 利用率下降</li></ul> <div align="center"><img src="/os-notes-figures/prognum-cpu-utility.png" width="260px" height="169px" alt="prognum-cpu-utility"></div> <h3 id="工作集置换算法"><a href="#工作集置换算法" class="header-anchor">#</a> 工作集置换算法</h3> <p>一个进程当前正在使用的逻辑页面集合，可表示为二元函数 W(t, Δ)</p> <ul><li>t 是当前的执行时刻</li> <li>Δ 称为工作集窗口（working-set window），即一个定长的页面访问时间窗口</li> <li>W(t, Δ) 是指在当前时刻 t 前的 Δ 时间窗口中的所有访问页面所组成的集合</li> <li>|W(t, Δ)| 指工作集的大小，即页面数目</li></ul> <p>一个进程的工作集的大小随着进程执行时间的变化而变化：</p> <div align="center"><img src="/os-notes-figures/working-set-size.png" width="357px" height="183px" alt="working-set-size"></div> <ol><li>进程开始执行后，随着访问新页面逐步建立较稳定的工作集</li> <li>当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定</li> <li>局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</li></ol> <p><strong>常驻集：</strong></p> <p>在当前时刻，进程实际驻留在内存当中的页面集合</p> <p><strong>工作集与常驻集的关系：</strong></p> <ul><li>工作集是进程在运行过程中的固有性质</li> <li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法</li></ul> <p><strong>缺页率和常驻集的关系：</strong></p> <ul><li>如果常驻集包含了工作集，缺页较少</li> <li>工作集发生剧烈变动（过渡）时，缺页较多</li> <li>进程常驻集大小达到一定数目后，缺页率也不会明显下降</li></ul> <p><strong>工作集置换算法：</strong></p> <ul><li>思路：换出不在工作集的页面</li> <li>窗口大小 𝞽，当前时刻前 𝞽 各内存访问的页引用是工作集，被称为窗口大小</li> <li>实现方法（开销大）
<ul><li>访存链表：链表用于维护窗口内的访存页面</li> <li>访存时，换出不在工作集的页面；更新访存链表</li> <li>缺页时，换入页面；更新访存链表</li></ul></li></ul> <h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="header-anchor">#</a> 缺页率置换算法</h3> <p>根据缺页之间的间隔来调整将哪些页面放到内存中，哪些页面需要被置换出去</p> <p><strong>缺页率（page fault rate）：</strong></p> <p>通常情况下，我们理解的缺页率是缺页的次数和访存次数之间的比值（缺页平均时间间隔的倒数）。影响缺页率的因素有：</p> <ol><li>页面置换算法</li> <li>分配给进程的物理页面数</li> <li>页面大小</li> <li>程序的编写方法</li></ol> <p><strong>缺页率置换算法（PFF，Page Fault Frequency）：</strong></p> <p>通过调节常驻集大小，使得每个进程的缺页率保持在一个合理的范围内</p> <p>![][page-fault-rate]
</p><div align="center"><img src="/os-notes-figures/page-fault-rate.png" width="263px" height="157px" alt="page-fault-rate"></div><p></p> <ol><li>若进程缺页率过高，则增加常驻集以分配更多的物理页面</li> <li>若进程缺页率过低，则减少常驻集以较少它的物理页面数</li></ol> <p><strong>实现：</strong></p> <ul><li>访存时，设置引用位标志</li> <li>缺页时，计算从上次缺页时间 t_{last} 到现在 t_{current} 的时间间隔</li> <li>如果 t_{current} - t_{last} &gt; T，则置换所有在 [t_{current}, t_{last}] 时间内没有被引用的页</li> <li>如果  t_{current} - t_{last} &lt;= T，则增加缺失页到常驻集中</li> <li>在工作集算法中，选择需要置换的页面是在访问时，开销比较大；在缺页率算法中，是在产生缺页中断时，会去考察缺页率是过低还是过高，将置换页面的操作放到缺页时来进行处理</li></ul> <h3 id="抖动（thrashing）"><a href="#抖动（thrashing）" class="header-anchor">#</a> 抖动（thrashing）</h3> <p>在系统中有多少个并发执行的进程在一起执行，对于系统来说是效率最高的</p> <p>抖动是由于在系统中执行的进程数目过多，每个进程分配到的物理页面数太少，减少到一定程度，不能包含工作集，因此造成大量缺页，频繁置换，进程运行速度变慢。即随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。</p> <p>操作系统需要在并发水平和缺页率之间达到一个平衡，选择一个适当的进程数目（调节并发进程数）和进程需要的物理页面数目（置换算法）</p> <h3 id="负载控制"><a href="#负载控制" class="header-anchor">#</a> 负载控制</h3> <p>通过调节并发进程数（MPL，Multi-Programming Level）来进行系统负载控制</p> <ul><li>𝞢WSi = 内存大小</li> <li>平均缺页间隔时间（MTBF，Mean Time Between Page Faults）</li> <li>缺页异常处理时间（PFST，Page Fault Service Time）</li></ul> <div align="center"><img src="/os-notes-figures/load-balance.png" width="363px" height="167px" alt="load-balance"></div> <p>目标：就整个系统处于均衡的繁忙状态</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/basic/os/2-virtual-memory.html" class="prev">
        虚拟存储
      </a></span> <span class="next"><a href="/basic/os/4-process-and-thread.html">
        进程与线程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e709e50c.js" defer></script><script src="/assets/js/2.aed79e5e.js" defer></script><script src="/assets/js/23.e2b0062c.js" defer></script>
  </body>
</html>
