<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lab 1 - Booting a PC | 在桥边</title>
    <meta name="description" content="偷得浮生半日闲">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.932e3e91.css" as="style"><link rel="preload" href="/assets/js/app.e709e50c.js" as="script"><link rel="preload" href="/assets/js/2.aed79e5e.js" as="script"><link rel="preload" href="/assets/js/30.113a865b.js" as="script"><link rel="prefetch" href="/assets/js/10.ebac5325.js"><link rel="prefetch" href="/assets/js/11.7b2d672a.js"><link rel="prefetch" href="/assets/js/12.54ea6fcf.js"><link rel="prefetch" href="/assets/js/13.db76fbea.js"><link rel="prefetch" href="/assets/js/14.fa058a50.js"><link rel="prefetch" href="/assets/js/15.9a7abe23.js"><link rel="prefetch" href="/assets/js/16.c2552b58.js"><link rel="prefetch" href="/assets/js/17.92650ebe.js"><link rel="prefetch" href="/assets/js/18.1329c666.js"><link rel="prefetch" href="/assets/js/19.856e1bd6.js"><link rel="prefetch" href="/assets/js/20.ae008e83.js"><link rel="prefetch" href="/assets/js/21.bf7a5edb.js"><link rel="prefetch" href="/assets/js/22.9037bd3b.js"><link rel="prefetch" href="/assets/js/23.e2b0062c.js"><link rel="prefetch" href="/assets/js/24.7a5dc9db.js"><link rel="prefetch" href="/assets/js/25.51d89d5c.js"><link rel="prefetch" href="/assets/js/26.05fca636.js"><link rel="prefetch" href="/assets/js/27.53049f31.js"><link rel="prefetch" href="/assets/js/28.4ec6e500.js"><link rel="prefetch" href="/assets/js/29.3710e311.js"><link rel="prefetch" href="/assets/js/3.ce4ee92b.js"><link rel="prefetch" href="/assets/js/31.32df48b4.js"><link rel="prefetch" href="/assets/js/32.6a9518d9.js"><link rel="prefetch" href="/assets/js/33.22fc30e7.js"><link rel="prefetch" href="/assets/js/34.dc080c4a.js"><link rel="prefetch" href="/assets/js/35.b9d1347c.js"><link rel="prefetch" href="/assets/js/36.012e0f79.js"><link rel="prefetch" href="/assets/js/37.52431a51.js"><link rel="prefetch" href="/assets/js/38.6bded00e.js"><link rel="prefetch" href="/assets/js/39.238f7705.js"><link rel="prefetch" href="/assets/js/4.796409a6.js"><link rel="prefetch" href="/assets/js/40.66e360c2.js"><link rel="prefetch" href="/assets/js/41.58481556.js"><link rel="prefetch" href="/assets/js/42.f8d39693.js"><link rel="prefetch" href="/assets/js/43.01ee4634.js"><link rel="prefetch" href="/assets/js/44.8481426f.js"><link rel="prefetch" href="/assets/js/45.aa1a9e0d.js"><link rel="prefetch" href="/assets/js/46.b9a5cb66.js"><link rel="prefetch" href="/assets/js/47.6963d786.js"><link rel="prefetch" href="/assets/js/48.b7224a2c.js"><link rel="prefetch" href="/assets/js/49.98dead63.js"><link rel="prefetch" href="/assets/js/5.ab04d8a1.js"><link rel="prefetch" href="/assets/js/50.d290680d.js"><link rel="prefetch" href="/assets/js/51.9317bcc1.js"><link rel="prefetch" href="/assets/js/52.56ac34b2.js"><link rel="prefetch" href="/assets/js/53.84b9fe5a.js"><link rel="prefetch" href="/assets/js/54.d134d158.js"><link rel="prefetch" href="/assets/js/55.09360f53.js"><link rel="prefetch" href="/assets/js/56.b88937d0.js"><link rel="prefetch" href="/assets/js/57.9781ff09.js"><link rel="prefetch" href="/assets/js/58.8632f2c4.js"><link rel="prefetch" href="/assets/js/59.0b61fe78.js"><link rel="prefetch" href="/assets/js/6.a8f689ef.js"><link rel="prefetch" href="/assets/js/60.b23c8bc9.js"><link rel="prefetch" href="/assets/js/61.99305fe8.js"><link rel="prefetch" href="/assets/js/62.b81b7ba9.js"><link rel="prefetch" href="/assets/js/63.27df456b.js"><link rel="prefetch" href="/assets/js/64.fa3ffb7b.js"><link rel="prefetch" href="/assets/js/65.c9d34a2b.js"><link rel="prefetch" href="/assets/js/66.2000d26a.js"><link rel="prefetch" href="/assets/js/67.aabdb00e.js"><link rel="prefetch" href="/assets/js/68.9ccf045a.js"><link rel="prefetch" href="/assets/js/69.0e0e4de8.js"><link rel="prefetch" href="/assets/js/7.83edc202.js"><link rel="prefetch" href="/assets/js/70.aef1292b.js"><link rel="prefetch" href="/assets/js/8.1d8b6d49.js"><link rel="prefetch" href="/assets/js/9.c0d52356.js">
    <link rel="stylesheet" href="/assets/css/0.styles.932e3e91.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">在桥边</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link router-link-active">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/os/" class="nav-link router-link-active">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/basic/algorithm/" class="nav-link">
  算法与数据结构
</a></li><li class="dropdown-item"><!----> <a href="/basic/network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/basic/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/basic/compiler/" class="nav-link">
  编译原理
</a></li><li class="dropdown-item"><!----> <a href="/basic/math/" class="nav-link">
  数学
</a></li><li class="dropdown-item"><!----> <a href="/basic/linux/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/lang/cpp/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/lang/go/" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/lang/js/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/lang/py/" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><a href="/system/" class="nav-link">
  分布式系统
</a></div><div class="nav-item"><a href="/source/" class="nav-link">
  源码阅读
</a></div><div class="nav-item"><a href="/reading/" class="nav-link">
  乱翻书
</a></div> <a href="https://github.com/qiaoin/qiaoin.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/basic/os/0-os-structures.html" class="sidebar-link">操作系统概述</a></li><li><a href="/basic/os/1-memory-management.html" class="sidebar-link">内存管理</a></li><li><a href="/basic/os/2-virtual-memory.html" class="sidebar-link">虚拟存储</a></li><li><a href="/basic/os/3-page-replacement-algo.html" class="sidebar-link">页面置换算法</a></li><li><a href="/basic/os/4-process-and-thread.html" class="sidebar-link">进程与线程</a></li><li><a href="/basic/os/5-scheduler.html" class="sidebar-link">CPU 调度</a></li><li><a href="/basic/os/6-synchronous-and-mutex.html" class="sidebar-link">同步互斥</a></li><li><a href="/basic/os/7-file-system.html" class="sidebar-link">文件系统</a></li><li><a href="/basic/os/8-io-subsystem.html" class="sidebar-link">IO 子系统</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MIT 6.828 实验</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/basic/os/mit-6.828-lab1.html" class="active sidebar-link">Lab 1 - Booting a PC</a></li><li><a href="/basic/os/mit-6.828-lab2.html" class="sidebar-link">Lab 2 - Memory Management</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="lab1-booting-a-pc"><a href="#lab1-booting-a-pc" class="header-anchor">#</a> <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener noreferrer">Lab1: Booting a PC<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h1> <blockquote><ul><li>【实验一于2019年4月3日开始做，环境配置及 Exercises，于4月6日完成，初稿报告4月7日】</li> <li>【2019年11月2日 第一次 review，发现了很多地方描述不清楚，需要补充上学习操作系统遇到的问题，痛点是什么？】</li> <li>【TODO】完善 lab1 实验笔记，只剩下 ex12 符号表部分内容</li></ul></blockquote> <p>实验分为三个部分：</p> <ul><li>1）<code>bootstrap</code> 执行流程，熟悉 x86 汇编，QEMU x86 模拟器，PC's power；</li> <li>2）<code>lab/boot</code> 目录，bootloader；</li> <li>3）<code>lab/kernel</code> 目录，JOS 内核初始化模块。</li></ul> <h2 id="part-1-pc-bootstrap"><a href="#part-1-pc-bootstrap" class="header-anchor">#</a> Part 1: PC Bootstrap</h2> <div class="custom-block tip"><p class="custom-block-title">Exercise 1</p> <p>熟悉内联汇编。</p></div> <p>阅读 <a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener noreferrer">Brennan's Guide to Inline Assembly<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，JOS 里面会使用 AT&amp;T 语法。另外还有更详细的参考资料：</p> <ul><li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener noreferrer">80386 Programmer's Reference Manual<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 包含在 6.828 中将要使用到的所有处理器特性的介绍；</li> <li><a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank" rel="noopener noreferrer">IA-32 Intel Architecture Software Developer's Manuals<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li> <li><a href="https://developer.amd.com/resources/developer-guides-manuals/" target="_blank" rel="noopener noreferrer">AMD64 Architecture Programmer's Manual<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li> <li>推荐阅读 <a href="https://www.linuxprobe.com/gcc-how-to.html" target="_blank" rel="noopener noreferrer">最牛 X 的 GCC 内联汇编<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，查看更完整的内容，整理的内容足够阅读内联汇编代码。</li></ul> <p><strong>【准备工作】为了进行下面的实验，需要进行一些配置</strong>：</p> <ol><li>按照 <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener noreferrer">Tools Used in 6.828<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 进行配置，macOS 需要按照网页说明安装定制化的 QEMU 模拟器：
<ul><li>安装 QEMU 的依赖文件，<code>brew install $(brew deps qemu)</code>；</li> <li>安装定制的 QEMU，假设安装在用户主目录下的 <code>~/opt/</code> 下，即 <code>./configure</code> 时指定 <code>--prefix=/Users/xxxx/opt</code>；</li> <li>Install 步骤 <code>PATH=${PATH}:/usr/local/opt/gettext/bin make install</code>；</li></ul></li> <li>安装 <code>i386</code> 相关依赖包 <code>brew install i386-elf-binutils i386-elf-gcc i386-elf-gdb</code>；</li> <li>不修改各个实验的 Makefile，转而修改用户主目录（<code>~</code>）下的 <code>.zshenv</code> (或者对应的 <code>.bashrc</code>)，这是对当前用户环境变量的全局修改：
<ul><li>找到 QEMU 可执行文件，<code>export PATH=&quot;/Users/xxxx/opt/bin:$PATH&quot;</code>；</li> <li>添加 <code>GCCPREFIX</code>，<code>export GCCPREFIX=&quot;i386-elf-&quot;</code>；</li> <li>添加 <code>gdb</code> 同名，<code>alias gdb=&quot;i386-elf-gdb&quot;</code>。</li></ul></li></ol> <div class="custom-block tip"><p class="custom-block-title">Exercise 2</p> <p>使用 GDB 进行调试，跟踪 ROM BIOS 指令的执行。</p></div> <ol><li>打开两个终端，<code>cd ~/6.828/lab</code>，到达相同的目录；</li> <li>一个终端启动 QEMU 模拟器的 GDB 模式执行 <code>make qemu-nox-gdb</code>，QEMU 在第一条指令之前暂停，等待 GDB 的连接；</li> <li>另一个终端执行 <code>gdb</code>（这里不是如 <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener noreferrer">Lab 1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 官网说明的执行 <code>make gdb</code>，而是执行 <code>gdb</code>，需要注意）。</li></ol> <p>最开始是一条跳转指令，跳转到 <code>0xfe05b</code> 进行执行：</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token info punctuation">[f000<span class="token punctuation">:</span><span class="token path">fff0]    0xffff0:  ljmp   </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0xf000,<span class="token variable">$0xe05b</span>  <span class="token comment"># 跳转指令</span></span></span>
</code></pre></div><p>使用 <code>si</code> 单步执行：</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token info punctuation">[f000<span class="token punctuation">:</span><span class="token path">d15f]    0xfd15f:   cli                    </span></span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">关闭中断</span></span>
<span class="token output">[f000:d171]    0xfd171:   lidtw  %cs:0x6ab8
</span><span class="token info punctuation">[f000<span class="token punctuation">:</span><span class="token path">d177]    0xfd177:   lgdtw  %cs:0x6a74      </span></span><span class="token output">#
[f000:d17d]    0xfd17d:   mov    %cr0,%eax
</span><span class="token info punctuation">[f000<span class="token punctuation">:</span><span class="token path">d180]    0xfd180:   or     </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x1,%eax</span></span>
<span class="token info punctuation">[f000<span class="token punctuation">:</span><span class="token path">d184]    0xfd184:   mov    %eax,%cr0       </span></span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">cr0 最低位置 <span class="token number">0</span></span></span>
</code></pre></div><p>BIOS 建立中断描述符表和初始化一系列硬件设备，进行一些检验工作，之后搜索可启动的设备，<strong>加载该存储设备上的第一个扇区的 512 字节到内存的 0x7C00</strong>（这是 BIOS 固件完成的），然后跳转到 <code>@0x7C00</code> 的第一条指令开始执行（<strong>将控制权转移给 bootloader</strong>）。</p> <p>设置断点在 <code>0x7c00</code>，<code>b *0x7c00</code>，继续执行 <code>c(ontinue)</code>：</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">[   0:7c00] =&gt; 0x7c00:    cli
[   0:7c01] =&gt; 0x7c01:    cld

[   0:7c1e] =&gt; 0x7c1e:    lgdtw  0x7c64
[   0:7c23] =&gt; 0x7c23:    mov    %cr0,%eax
</span><span class="token info punctuation">[   0<span class="token punctuation">:</span><span class="token path">7c26] =&gt; 0x7c26:    or     </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x1,%eax</span></span>
<span class="token output">[   0:7c2a] =&gt; 0x7c2a:    mov    %eax,%cr0
</span><span class="token info punctuation">[   0<span class="token punctuation">:</span><span class="token path">7c2d] =&gt; 0x7c2d:    ljmp   </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x8,<span class="token variable">$0x7c32</span></span></span>
</code></pre></div><p>执行 <code>x/Ni ADDR</code> 打印从 <code>ADDR</code> 地址开始的连续 <code>N</code> 条汇编指令（以上关于 BIOS 的部分不是 6.828 重点关注的部分，执行时单步跟踪能够看出一点端倪，具体在 lab 实验目录中没有源码对应）。</p> <h2 id="part-2-the-boot-loader"><a href="#part-2-the-boot-loader" class="header-anchor">#</a> Part 2: The Boot Loader</h2> <p><code>bootloader</code> 主要做三件事：</p> <ul><li>1）从实模式（real mode）切换到保护模式（32-bit protected mode）。在实模式下只能寻址 1MB 的内存空间（2^20），在保护模式下能够寻址 4GB（2^32），这样就能够访问处理器全部的物理内存空间；</li> <li>2）读取内核映像到内存中固定位置，ELF 文件格式（解析 ELF 文件，将内核需要加载进入内存的段 &lt;有 LOAD 标记的段&gt; 加载进内存，放置在指定的加载地址）；</li> <li>3）把控制权转移给 JOS，即将 <code>CS:EIP</code> 的值指向操作系统内核所在内存中的起始点（<code>.text</code> 段中程序开始执行时的起始地址）。</li></ul> <p>两个源文件代码的阅读：</p> <ul><li><strong><code>boot/boot.S</code></strong>：执行 <code>start</code> 函数，进行一定的初始化，完成从实模式到保护模式的切换（<code>CR0</code> 最低位设置为 1），并调用 <code>bootmain</code> 函数，具体细节参见 <code>bootloader</code> 实模式切换到保护模式（Google 一下）；</li> <li><strong><code>boot/main.c</code></strong>：<code>bootloader</code> 让 CPU 进入保护模式后，下一步的工作就是<strong>从硬盘上加载并运行 OS</strong>。考虑到实现的简单性，<code>bootloader</code> 访问硬盘都是 LBA 模式 的 <strong>PIO</strong>（Program IO）方式，即<strong>所有的 IO 操作是通过 CPU 访问硬盘的 IO 地址寄存器完成</strong>。当前硬盘数据是储存到硬盘扇区中，一个扇区大小为 512 字节。读一个扇区的流程（可参看 <code>readsect</code> 函数实现，大致理解就可以）大致如下：
<ol><li>等待磁盘准备好；</li> <li>发出读取扇区的命令；</li> <li>等待磁盘准备好；</li> <li>把磁盘扇区数据读到指定内存。</li></ol></li></ul> <p>主要查看 <code>bootmain</code> 函数实现：</p> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">define</span> SECTSIZE    512                      </span><span class="token comment">// 扇区大小 512 字节</span>
<span class="token macro property">#<span class="token directive keyword">define</span> ELFHDR      ((struct Elf *) 0x10000) </span><span class="token comment">// 将 0x10000 设置为内核起始地址</span>

<span class="token keyword">void</span> <span class="token function">bootmain</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Proghdr</span> <span class="token operator">*</span>ph<span class="token punctuation">,</span> <span class="token operator">*</span>eph<span class="token punctuation">;</span>

    <span class="token comment">// 从硬盘的第一个扇区（偏移为 0）读取 8*512=4096byte （4KB）的内容到内存单元 ELFHDR 处</span>
    <span class="token function">readseg</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span> ELFHDR<span class="token punctuation">,</span> SECTSIZE<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1.</span>

    <span class="token comment">// is this a valid ELF?</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ELFHDR<span class="token operator">-&gt;</span>e_magic <span class="token operator">!=</span> ELF_MAGIC<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>

    <span class="token comment">// load each program segment (ignores ph flags)</span>
    ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Proghdr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span> ELFHDR <span class="token operator">+</span> ELFHDR<span class="token operator">-&gt;</span>e_phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2.</span>
    eph <span class="token operator">=</span> ph <span class="token operator">+</span> ELFHDR<span class="token operator">-&gt;</span>e_phnum<span class="token punctuation">;</span>  <span class="token comment">// program header 的个数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token comment">// p_pa is the load address of this segment (as well</span>
        <span class="token comment">// as the physical address)</span>
        <span class="token function">readseg</span><span class="token punctuation">(</span>ph<span class="token operator">-&gt;</span>p_pa<span class="token punctuation">,</span> ph<span class="token operator">-&gt;</span>p_memsz<span class="token punctuation">,</span> ph<span class="token operator">-&gt;</span>p_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3.</span>

    <span class="token comment">// call the entry point from the ELF header</span>
    <span class="token comment">// note: does not return!</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ELFHDR<span class="token operator">-&gt;</span>e_entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 4.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>关键的几行代码已经标注序号，需要结合下面 ELF 文件格式来进行理解。</p> <ol><li>将 kernel 从磁盘中读取到内存的指定位置 <code>ELFHDR</code>，<code>0x10000</code>；</li> <li>对 <code>ELFHDR</code> 处的 ELF header 进行解析，得到 program header table 的起始地址存放在 <code>ph</code> 中，结束地址存放在 <code>eph</code> 中。这里将 <code>ELFHDR</code> 进行转型为 <code>uint8_t</code> 指针，这样在进行指针加法时，这个指针变量按照 byte 的偏移来加，得到 program header table 的起始地址，并转换为 <code>struct Proghdr</code> 类型指针：<div class="language-c extra-class"><pre class="language-c"><code>ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Proghdr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span> ELFHDR <span class="token operator">+</span> ELFHDR<span class="token operator">-&gt;</span>e_phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>根据每个 program header 的信息从磁盘读取各个段进入内存指定位置，从 <code>ph-&gt;p_offset</code> 处开始拷贝 <code>ph-&gt;p_memsz</code> 个 bytes 到 <code>ph-&gt;p_pa</code>：<div class="language-c extra-class"><pre class="language-c"><code><span class="token function">readseg</span><span class="token punctuation">(</span>ph<span class="token operator">-&gt;</span>p_pa<span class="token punctuation">,</span> ph<span class="token operator">-&gt;</span>p_memsz<span class="token punctuation">,</span> ph<span class="token operator">-&gt;</span>p_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>在将内核加载到内存中后，转移到 entry point 开始执行，即 JOS 开始运行时要执行的第一条指令的地址。这里将 <code>e_entry</code> 转换为一个无参数无返回值的函数，并执行函数调用：<div class="language-c extra-class"><pre class="language-c"><code><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ELFHDR<span class="token operator">-&gt;</span>e_entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <div class="custom-block tip"><p class="custom-block-title">Exercise 3</p> <p>使用 GDB 单步跟踪执行。</p></div> <p>设置断点在 <code>0x7c00</code>，<code>b *0x7c00</code>，另外还设置两个断点：</p> <ul><li>1）<code>b *0x7d56</code>，<code>bootmain</code> 函数 <code>for</code> 循环开始处；</li> <li>2）<code>b *0x7d71</code>，ELF 调用 entry point 处。</li></ul> <p>继续执行 <code>c(ontinue)</code>，就可以看到 <code>for</code> 循环处的断点 hit 3 次（最后一次是判断 <code>for</code> 循环条件不成立），说明根据 ELF header 信息读入了另外 2 个段（<code>.text</code>/<code>.data</code>，可以使用 <code>i386-elf-objdump -x obj/kern/kernel</code> 命令查看到 Program Header）。执行到达 <code>0x7d71</code> 处时，对应汇编指令为：</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">0x7d71: call   *0x10018
</span></code></pre></div><p>但 <code>si</code> 单步执行的真实地址为 <code>0x10000c</code>：</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">(gdb) x/10i 0x10000c
</span><span class="token info punctuation">=&gt; 0x10000c<span class="token punctuation">:</span><span class="token path">    movw   </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x1234,0x472</span></span>
<span class="token info punctuation">   0x100015<span class="token punctuation">:</span><span class="token path">    mov    </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x110000,%eax</span></span>
<span class="token output">   0x10001a:    mov    %eax,%cr3
   0x10001d:    mov    %cr0,%eax
</span><span class="token info punctuation">   0x100020<span class="token punctuation">:</span><span class="token path">    or     </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x80010001,%eax</span></span>
<span class="token output">   0x100025:    mov    %eax,%cr0
</span><span class="token info punctuation">   0x100028<span class="token punctuation">:</span><span class="token path">    mov    </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0xf010002f,%eax</span></span>
<span class="token output">   0x10002d:    jmp    *%eax                &lt;- 0xf010002f &lt;relocated&gt;
</span><span class="token info punctuation">   0x10002f<span class="token punctuation">:</span><span class="token path">    mov    </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x0,%ebp</span></span>
<span class="token info punctuation">   0x100034<span class="token punctuation">:</span><span class="token path">    mov    </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0xf0110000,%esp</span></span>
</code></pre></div><p>回答以下 4 个问题：</p> <ol><li><p>在哪个时间点处理器开始执行 32-bit 代码？导致从 16-bit 切换到 32-bit 的关键操作是什么？</p> <p>使能保护模式（置 <code>CR0</code> 最低位为 1）和段机制（建立好全局描述符表 <code>GDT</code>）。执行一条长跳转指令 <code>ljmp cs:eip</code> 转而执行 32-bit 模式。</p></li> <li><p><code>bootloader</code> 执行的最后一条指令是什么？kernel 在加载之后，执行的第一条指令是什么？</p> <div class="language-shell-session extra-class"><pre class="language-shell-session"><code><span class="token output">call   *0x10018
</span><span class="token info punctuation">0x10000c<span class="token punctuation">:</span><span class="token path">  movw   </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x1234,0x472</span></span>
</code></pre></div><p>这两个地址不相同，这是为什么？因为开启了<strong>分页机制</strong>，虚拟地址与物理地址之间的映射关系已建立好。</p></li> <li><p>kernel 执行的第一条指令的地址是多少？</p> <p><code>0x10000c</code></p></li> <li><p>为了将整个 kernel 从磁盘加载到内存中，<code>bootloader</code> 是如何确定需要读入的扇区数目的？这些信息存储在哪里？</p> <div class="language-c extra-class"><div class="highlight-lines"><br><div class="highlighted"> </div><br><br><br><br><br><br><br></div><pre class="language-c"><code><span class="token comment">// load each program segment (ignores ph flags)</span>
ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Proghdr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span> ELFHDR <span class="token operator">+</span> ELFHDR<span class="token operator">-&gt;</span>e_phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ii</span>
eph <span class="token operator">=</span> ph <span class="token operator">+</span> ELFHDR<span class="token operator">-&gt;</span>e_phnum<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token comment">// p_pa is the load address of this segment (as well</span>
    <span class="token comment">// as the physical address)</span>
    <span class="token function">readseg</span><span class="token punctuation">(</span>ph<span class="token operator">-&gt;</span>p_pa<span class="token punctuation">,</span> ph<span class="token operator">-&gt;</span>p_memsz<span class="token punctuation">,</span> ph<span class="token operator">-&gt;</span>p_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3.</span>
</code></pre></div><p>在 ELF 文件的 program header 中包含总共需要读取的数据大小，同时对于需加载进内存中的各个段，也标注了在磁盘上的偏移位置和大小。</p></li></ol> <div class="custom-block tip"><p class="custom-block-title">Exercise 4</p> <p>C 语言中的指针。</p></div> <p>C 程序设计语言 第 5 章 数组与指针 5.1 - 5.5（待读，之前已经看过好几遍了）。</p> <h3 id="elf-文件格式（没有很明白，20191102晚上11点57分）"><a href="#elf-文件格式（没有很明白，20191102晚上11点57分）" class="header-anchor">#</a> ELF 文件格式（没有很明白，20191102晚上11点57分）</h3> <p>ELF header + 待加载的信息（包含连续的多个段，数据段和代码段等，这些段需要从磁盘加载到内存的指定地址）。<code>bootloader</code> 不会去修改数据段和代码段，只是将它们加载进内存，然后将控制权转移给这些程序进行执行。</p> <p>ELF header 长度固定（fixed-length），后跟可变长度（variable-length）的 program header，列出了要加载的各个程序段（program sections）。<code>inc/elf.h</code> 定义了 <code>ELF header</code>：</p> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">Elf</span> <span class="token punctuation">{</span>            <span class="token comment">// ELF 文件头</span>
    uint32_t e_magic<span class="token punctuation">;</span>   <span class="token comment">// must equal ELF_MAGIC</span>
    uint8_t e_elf<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    uint16_t e_type<span class="token punctuation">;</span>
    uint16_t e_machine<span class="token punctuation">;</span>
    uint32_t e_version<span class="token punctuation">;</span>
    uint32_t e_entry<span class="token punctuation">;</span>   <span class="token comment">// 程序开始执行的起始地址</span>
    uint32_t e_phoff<span class="token punctuation">;</span>   <span class="token comment">// program header table 的起始位置</span>
    uint32_t e_shoff<span class="token punctuation">;</span>   <span class="token comment">// section header 的起始位置</span>
    uint32_t e_flags<span class="token punctuation">;</span>
    uint16_t e_ehsize<span class="token punctuation">;</span>  <span class="token comment">// ELF 文件本身的大小</span>
    uint16_t e_phentsize<span class="token punctuation">;</span>
    uint16_t e_phnum<span class="token punctuation">;</span>   <span class="token comment">// program header 的个数</span>
    uint16_t e_shentsize<span class="token punctuation">;</span>
    uint16_t e_shnum<span class="token punctuation">;</span>
    uint16_t e_shstrndx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Proghdr</span> <span class="token punctuation">{</span>        <span class="token comment">// program header table</span>
    uint32_t p_type<span class="token punctuation">;</span>
    uint32_t p_offset<span class="token punctuation">;</span>
    uint32_t p_va<span class="token punctuation">;</span>      <span class="token comment">// 虚拟地址</span>
    uint32_t p_pa<span class="token punctuation">;</span>      <span class="token comment">// 物理地址</span>
    uint32_t p_filesz<span class="token punctuation">;</span>  <span class="token comment">// 段在文件中的大小</span>
    uint32_t p_memsz<span class="token punctuation">;</span>   <span class="token comment">// 段在内存中的大小</span>
    uint32_t p_flags<span class="token punctuation">;</span>   <span class="token comment">// 读写执行权限</span>
    uint32_t p_align<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>【TODO】这里为什么需要 <code>p_filesz</code>、<code>p_memsz</code> 两个长度呢？在之后会介绍到，<code>.bss</code> 在磁盘上没有存储空间，在内存中程序需要为其分配空间。</p> <p><code>bootloader</code> 利用 ELF program header 来决定如何加载各 program sections，而 program header 指定应该读取 ELF 对象的哪个部分进内存，以及应该放在哪里。</p> <div align="center"><img src="/mit-6.828-lab1-figures/elf-layout.png" width="322px" height="358px" alt="elf-layout"></div> <div align="center"><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia</a></div> <p>在 6.828 实验中将用到的 program sections：</p> <ul><li><strong><code>.text</code></strong>：代码段。程序的可执行指令；</li> <li><code>.rodata</code>：只读数据段。例如 C 编译器产生的 ASCII 字符串常量；</li> <li><strong><code>.stab</code></strong>：符号表部分，在程序报错时提供错误信息；</li> <li><strong><code>.stabstr</code></strong>：符号表字符串部分；</li> <li><strong><code>.data</code></strong>：数据段。已初始化的全局变量和局部静态变量；</li> <li><code>.bss</code>：为未初始化的全局变量和局部静态变量预留位置，但并没有内容，因此在文件中也不占据磁盘空间（因此需要 <code>p_filesz</code>、<code>p_memsz</code> 两个长度）。由于未初始化的全局变量和局部静态变量默认值都是 0，本来它们也可以被放在 <code>.data</code> 段里，但是因为它们都是 0，为它们在 <code>.data</code> 段分配空间并存放数据 0 是没有必要的；</li> <li>...</li></ul> <div class="language-shell-session extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-shell-session"><code><span class="token output">i386-elf-objdump -h obj/kern/kernel

obj/kern/kernel:     file format elf32-i386
Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000171e  f0100000  00100000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000714  f0101720  00101720  00002720  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .stab         000040ed  f0101e34  00101e34  00002e34  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .stabstr      00001957  f0105f21  00105f21  00006f21  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         0000a300  f0108000  00108000  00009000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000648  f0112300  00112300  00013300  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  6 .debug ......
  ......
</span></code></pre></div><p>得到 ELF 文件各个段的基本信息，可以知道很多段都是 Debug 信息（program loader 不会将这些段加载进内存）。</p> <p>查看更详细的信息：</p> <div class="language-shell-session extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-shell-session"><code><span class="token output">i386-elf-objdump -x obj/kern/kernel

obj/kern/kernel:     file format elf32-i386
obj/kern/kernel
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0010000c

Program Header:
    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12
         filesz 0x00007878 memsz 0x00007878 flags r-x
    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12
         filesz 0x0000a948 memsz 0x0000a948 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000171e  f0100000  00100000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       ...
  2 .stab         ...
  3 .stabstr      ...
  4 .data         0000a300  f0108000  00108000  00009000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  ......
</span></code></pre></div><p>对于内核映像，其链接地址和加载地址不同，内核希望 <code>bootloader</code> 将其加载到低物理地址处（<strong><code>0x00100000</code></strong> 最下面的 <code>1MB</code> 处），但是期望在高地址（虚拟地址）处进行执行（<strong><code>0xf0100000</code></strong>）。这里带标识 <code>LOAD</code> 的 Program Header 段（可能一个段包含多个 Sections，<code>.data</code>/<code>.text</code>/etc.），即多个 Sections 被同时加载进入内存。</p> <h3 id="链接地址和加载地址（link-address-and-load-address）"><a href="#链接地址和加载地址（link-address-and-load-address）" class="header-anchor">#</a> 链接地址和加载地址（link address and load address）</h3> <p>我们关注 <code>.text</code> 段的 <code>VMA</code>(or link address，虚拟地址) 和 <code>LMA</code>(or load address，物理地址)。段的 <code>LMA</code>(load address)指定了将这个段加载进内存时需要放置的物理地址。段的 <code>VMA</code>(link address)指定了程序执行时这个段需要放置在内存中的虚拟地址。为了保证程序能够正常的执行，需要进行链接。</p> <p><strong>链接地址实际上就是程序假设自己在内存中被存放的位置，即编译器在编译的时候会认定程序将会连续的存放在从链接地址起始处开始的内存空间。而加载地址是可执行程序在物理内存中真正存放的位置</strong>，在 JOS 中，<code>bootloader</code> 是被 BIOS 装载到内存的，由于 BIOS 实际上规定 <code>bootloader</code> 要被存放在物理内存的 <code>0x7c00</code> 处，于是不论程序的链接地址怎么改变，它装载在内存中的位置（加载地址）都不会变化。</p> <p><strong>链接地址是指令运行时的地址，加载地址是指令加载到内存中的地址。实模式下这两个地址是一样的，因为没有开启分页机制，指令执行的时候就没有地址映射关系</strong>。</p> <p>我们可以看到 <code>bootloader</code> 的链接地址和加载地址是相等的，为 <code>0x7c00</code>：</p> <div class="language-shell-session extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-shell-session"><code><span class="token output">i386-elf-objdump -h obj/boot/boot.out

obj/boot/boot.out:     file format elf32-i386
Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000018c  00007c00  00007c00  00000054  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  1 .eh_frame     0000009c  00007d8c  00007d8c  000001e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .stab         00000744  00000000  00000000  0000027c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      000008e1  00000000  00000000  000009c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000011  00000000  00000000  000012a1  2**0
                  CONTENTS, READONLY
</span></code></pre></div><div class="custom-block tip"><p class="custom-block-title">Exercise 5</p> <p>修改 <code>boot/Makefrag</code>，将 bootloader 的 link address 改为非 <code>0x7c00</code> 的数值，看看会出现什么问题？</p></div> <p>在 <code>boot/Makefrag</code> 中指定了 <code>bootloader</code> 的链接地址 <code>-Ttext 0x7C00</code>，现在我们将链接地址修改为 <code>0x8C00</code>，重新编译：</p> <ol><li>设置断点 <code>b *0x7c00</code>，BIOS 一定会将 <code>bootloader</code> 加载到这个位置；</li> <li><code>si</code> 单步跟踪执行，执行到 <code>0x7c2d: ljmp $0x8,$0x8c32</code> 指令时发生错误；</li> <li>查看编译同时生成的反汇编文件 <code>obj/boot/boot.asm</code>，其中显示了汇编指令和相应的链接地址，由于我们修改了 bootloader 的链接地址为 <code>0x8c00</code>，<code>“ljmp $0x8,$0x8c32”</code> 这条指令在 <code>boot.asm</code> 文件中显示的实际汇编地址为 <code>0x8c2d</code>，其后的 <code>protcseg</code> 标识的指令的链接地址为 <code>0x8c32</code>，即 <code>si</code> 单步执行到 <code>0x8c2d</code> 处需要跳转到的标识符地址；</li> <li>CPU 报错？为什么会报错呢？链接是怎么做的？</li></ol> <p><code>VMA</code>/<code>LMA</code> 是给加载器做参考，告诉加载器“需要将某个段加载到某某地址”，但现在连操作系统都还没有运行起来，更不会有加载器。因此，<code>bootloader</code> 的源代码还是会被加载到内存的 <code>0x7c00</code> 处（因为 BIOS 在 ROM，里面的程序代码是在出厂时就已经规定好了的，将磁盘的第一个扇区加载到内存的 <code>0x7c00</code> 处）。链接最重要的一步是符号重定位（symbol relocation），在源代码 <code>boot/boot.S</code> 中：</p> <div class="language-asm6502 extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted"> </div><br><br></div><pre class="language-asm6502"><code>  # Jump to next instruction, but in <span class="token decimalnumber string">32</span>-<span class="token opcode property">bit</span> code segment.
  # Switches processor into <span class="token decimalnumber string">32</span>-<span class="token opcode property">bit</span> mode.
  ljmp    $PROT_MODE_CSEG, $protcseg
  <span class="token directive keyword">.code32</span>                     # Assemble for <span class="token decimalnumber string">32</span>-<span class="token opcode property">bit</span> mode
protcseg:
  # Set up the protected-mode data segment registers
</code></pre></div><p>这里的 <code>protcseg</code> 符号（symbol）用来标记位置，可以是一段子程序的起始地址，也可以是一个变量的起始地址。在这里 <code>protcseg</code> 表示一段程序的起始地址，在编译生成可重定位目标文件（relocatable object file）时其值是不确定的。在链接时，链接器会对这些符号进行替换（因为程序已经链接好了）。</p> <p>现在的问题是，链接器按照 <code>0x8C00</code> 的链接起始地址对这些符号进行替换，但 BIOS 还是将 bootloader 读到了内存中的 <code>0x7C00</code> 处，实模式下（仅开启了段机制），加载地址和链接地址应该是相同的。而现在，<code>ljmp</code> 指令要跳转到 <code>0x8c32</code> 处，本来应该跳转到下一条指令 <code>0x7c32</code> 处。【TODO 需要更加细致的分析！】</p> <div class="language-shell-session extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br></div><pre class="language-shell-session"><code><span class="token output">(gdb) x/10i 0x7c1e
   0x7c1e: lgdtw  -0x739c
   0x7c23: mov    %cr0,%eax
</span><span class="token info punctuation">   0x7c26<span class="token punctuation">:</span><span class="token path"> or     </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x1,%eax</span></span>
<span class="token output">   0x7c2a: mov    %eax,%cr0
</span><span class="token info punctuation">=&gt; 0x7c2d<span class="token punctuation">:</span><span class="token path"> ljmp   </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0x8,<span class="token variable">$0x8c32</span></span></span>
<span class="token info punctuation">   0x7c32<span class="token punctuation">:</span><span class="token path"> mov    </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0xd88e0010,%eax</span></span>
<span class="token output">   0x7c38: mov    %ax,%es
   0x7c3a: mov    %ax,%fs
   0x7c3c: mov    %ax,%gs
   0x7c3e: mov    %ax,%ss
</span></code></pre></div><div class="custom-block tip"><p class="custom-block-title">Exercise 6</p> <p>执行 <code>x/Nx ADDR</code> 打印从 <code>ADDR</code> 开始的 <code>N</code> 个 word（在 GNU 汇编标准中，1 word = 2 bytes）。在两个不同的时刻检查 <code>0x00100000</code> 出的 8 个 word，1）BIOS 将控制权转移给 <code>bootloader</code> 和 2）<code>bootloader</code> 将 JOS 内核映像读入内存之后，将控制权转移给 JOS（entry point），有什么不一样，并且为什么这 8 个 word 会不一样？</p></div> <ol><li>关闭 QEMU 和 GDB，重新运行；</li> <li>设置断点 <code>b *0x7c00</code>（BIOS 将控制权转移给 <code>bootloader</code>）和 <code>b *0x7d71</code>（<code>bootloader</code> 将控制权转移给 JOS）。</li></ol> <div align="center"><img src="/mit-6.828-lab1-figures/ex-6.png" width="600px" height="501px" alt="ex-6"></div> <p>前后两次执行 <code>x/Nx ADDR</code> 结果不一样，第二次是因为我们使用 <code>bootloader</code> 将 JOS 的程序段（Program Header 中有 <code>LOAD</code> 标记的段）加载到了 <code>0x100000</code> 处，因此，从 <code>0x100000</code> 开始都存放着 <strong>JOS 内核映像</strong>。</p> <h2 id="part-3：the-kernel"><a href="#part-3：the-kernel" class="header-anchor">#</a> Part 3：The Kernel</h2> <p>操作系统内核一般链接地址都比较大，会选择在高虚拟地址空间上运行，将低虚拟地址空间留给用户程序使用（在 Lab2 中会进行更清晰的解释）。</p> <p>很多机器的物理内存空间地址都不会到达 <strong><code>0xf010002f</code></strong>，因此 JOS 内核映像不会真实存储于此，而是，我们使用处理器的内存管理硬件（memory management hardware）将高虚拟地址空间 <strong><code>0xf0100000</code></strong>（内核的链接地址，期望运行的虚拟地址）映射到实际的低物理地址空间 <strong><code>0x00100000</code></strong>（内核的加载地址，<code>bootloader</code> 将内核映像加载进内存中的地址），<code>bootloader</code> 加载磁盘上的内核映像存放在内存中的地址为 <strong><code>0x00100000</code></strong>（刚好在 BIOS ROM 的上面，从 1MB 地址往上），可以查看命令 <code>i386-elf-objdump -x obj/kern/kernel</code> 的返回内容。</p> <p><code>kern/entrypgdir.c</code> 中已经建立好了虚拟地址和物理地址的映射关系 <code>entry_pgdir</code>：</p> <ul><li>Map VA's [0, 4MB) to PA's [0, 4MB)</li> <li>Map VA's [<code>KERNBASE</code>, <code>KERNBASE</code>+4MB) to PA's [0, 4MB) 其中，<code>KERNBASE=0xF0000000</code></li></ul> <p>在 <code>kern/entry.S</code> 中会对 <code>CR0_PG</code> flag 进行设置，在此设置之前，代码中对内存的引用（memory references）都会被解释为物理地址（更准确的说是线性地址，在 <code>boot/boot.S</code> 中仅开启段机制，线性地址与物理地址相等），当对 <code>CR0_PG</code> 设置之后，对内存的引用将被解释为虚拟地址（即开启页机制），再由 <code>entry_pgdir</code> 翻译为对应的物理地址：</p> <ul><li>将 <code>0xf0000000 ~ 0xf0400000</code> 虚拟地址翻译为对应的物理地址 <code>0x00000000 ~ 0x00400000</code></li> <li>将 <code>0x00000000 ~ 0x00400000</code> 虚拟地址翻译为对应的物理地址 <code>0x00000000 ~ 0x00400000</code></li></ul> <p>在内核被加载到内存后系统便立即跳转开始执行 <code>kern/entry.S</code> 的代码，这个文件中的程序相当于内核的入口程序：</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code>.globl      _start
_start = RELOC(entry)

<span class="token directive keyword">.globl</span> entry
entry:
    movw    $<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">1234</span>,<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">472</span>           # warm boot

    # We haven<span class="token string">'t set up virtual memory yet, so we'</span>re running from
    # the physical address the boot loader loaded the kernel at: <span class="token decimalnumber string">1</span>MB
    # (plus <span class="token register variable">a</span> few bytes).  However, the C code is linked to run at
    # KERNBASE+<span class="token decimalnumber string">1</span>MB.  Hence, we set up <span class="token register variable">a</span> trivial page directory that
    # translates virtual addresses [KERNBASE, KERNBASE+<span class="token decimalnumber string">4</span>MB) to
    # physical addresses [<span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">4</span>MB).  This <span class="token decimalnumber string">4</span>MB region will be
    # sufficient until we set up our real page table in mem_init
    # in lab <span class="token decimalnumber string">2</span>.

    # Load the physical address of entry_pgdir into cr<span class="token decimalnumber string">3</span>.  entry_pgdir
    # is defined in entrypgdir.c.
    movl    $(RELOC(entry_pgdir)), %eax
    movl    %eax, %cr<span class="token decimalnumber string">3</span>
    # Turn on paging. 开启页机制
    movl    %cr<span class="token decimalnumber string">0</span>, %eax
    orl $(CR<span class="token decimalnumber string">0</span>_PE|CR<span class="token decimalnumber string">0</span>_PG|CR<span class="token decimalnumber string">0</span>_WP), %eax
    movl    %eax, %cr<span class="token decimalnumber string">0</span>

    # Now paging is enabled, but we're still running at <span class="token register variable">a</span> low EIP
    # (why is this okay?).  Jump up above KERNBASE before entering
    # C code.
    mov $relocated, %eax  # $relocated 为链接地址，因此需要重定位
    <span class="token opcode property">jmp</span> *%eax
relocated:

    # Clear the frame pointer register (EBP)
    # so that once we get into debugging C code,
    # stack backtraces will be terminated properly.
    movl    $<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">0</span>,%ebp           # nuke frame pointer

    # Set the stack pointer
    movl    $(bootstacktop),%esp

    # now to C code
    call    i<span class="token decimalnumber string">386</span>_init
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">Exercise 7</p> <p>使用 QEMU 和 GDB 单步跟踪 JOS，执行到 <code>movl %eax, %cr0</code>，检查在执行这条汇编指令前后内存单元 <code>0x00100000</code> 和 <code>0xf0100000</code> 的内容。</p></div> <ol><li>设置断点 <code>b *0x7d71</code>（<code>bootloader</code> 将控制权转移给 JOS）；</li> <li><code>si</code> 单步跟踪执行。</li></ol> <div class="language-shell-session extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-shell-session"><code><span class="token output">=&gt; 0x100025:    mov    %eax,%cr0
(gdb) x/8x 0x00100000
0x100000:                       0x1badb002 0x00000000 0xe4524ffe 0x7205c766
0x100010:                       0x34000004 0x0000b812 0x220f0011 0xc0200fd8
(gdb) x/8x 0xf0100000
0xf0100000 &lt;_start+4026531828&gt;: 0x00000000 0x00000000 0x00000000 0x00000000
0xf0100010 &lt;entry+4&gt;:           0x00000000 0x00000000 0x00000000 0x00000000
(gdb) si
</span><span class="token info punctuation">=&gt; 0x100028<span class="token punctuation">:</span><span class="token path">    mov    </span></span><span class="token command"><span class="token shell-symbol important">$</span><span class="token bash language-bash">0xf010002f,%eax</span></span>
<span class="token output">(gdb) x/8x 0x00100000
0x100000:                       0x1badb002 0x00000000 0xe4524ffe 0x7205c766
0x100010:                       0x34000004 0x0000b812 0x220f0011 0xc0200fd8
(gdb) x/8x 0xf0100000
0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002 0x00000000 0xe4524ffe 0x7205c766
0xf0100010 &lt;entry+4&gt;:           0x34000004 0x0000b812 0x220f0011 0xc0200fd8
</span></code></pre></div><p>执行 <code>mov %eax, %cr0</code> 之后，建立好了虚拟地址和物理地址的映射关系。如果将这条指令给注释掉，重新编译执行，同样设置断点，在 <code>0xf010002c &lt;relocated&gt;: add %al,(%eax)</code> 处 QEMU 出错退出，出错信息为：“qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c”。</p> <h3 id="cprintf-函数的实现（c-语言中常用的-printf-函数）"><a href="#cprintf-函数的实现（c-语言中常用的-printf-函数）" class="header-anchor">#</a> <code>cprintf</code> 函数的实现（C 语言中常用的 <code>printf</code> 函数）</h3> <p>三个源文件代码的阅读：【TODO 分析并实现 <code>printf</code> 函数，包括实现浮点数打印】</p> <ul><li><code>kern/printf.c</code>：封装格式化输出函数，提供 <code>cprintf</code> 函数接口；</li> <li><code>lib/printfmt.c</code>：格式化字符串输出，需好好学习这个源码文件；</li> <li><code>kern/console.c</code>：实现基本的 I/O 操作，提供 <code>cputchar</code>/<code>getchar</code> 供 <code>readline</code>/<code>cprinf</code> 使用。</li></ul> <div class="custom-block tip"><p class="custom-block-title">Exercise 8</p> <p>填充代码，支持使用 &quot;%o&quot; 打印八进制数（这个很简单，模仿着写，但需理解）。</p></div> <div class="language-c extra-class"><pre class="language-c"><code>        <span class="token comment">// (unsigned) octal</span>
        <span class="token keyword">case</span> <span class="token string">'o'</span><span class="token operator">:</span>
            num <span class="token operator">=</span> <span class="token function">getuint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ap<span class="token punctuation">,</span> lflag<span class="token punctuation">)</span><span class="token punctuation">;</span>
            base <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
            <span class="token keyword">goto</span> number<span class="token punctuation">;</span>
</code></pre></div><p>在 <code>kern/init.c i386_init()</code> 函数中添加测试代码。</p> <h3 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h3> <p>几条与栈相关的汇编指令解释：</p> <table><thead><tr><th>汇编指令</th> <th>解释</th></tr></thead> <tbody><tr><td>pushl %eax</td> <td>subl $4, %esp; movl %eax, (%esp)</td></tr> <tr><td>popl %eax</td> <td>movl (%esp), %eax; addl $4, %esp</td></tr> <tr><td>call 0x1234</td> <td>pushl %eip; movl 0x1234, %eip</td></tr> <tr><td>ret</td> <td>popl %eip</td></tr></tbody></table> <p>（注：这里为了解释清晰，右侧指令大都不规范。）</p> <p><strong>栈的生长方向是高地址到低地址</strong>，<code>esp</code> 指向栈顶（低地址），<code>ebp</code> 指向栈底（高地址）。</p> <ol><li>当进入一个函数（<code>callee</code>）进行执行时，将调用者（<code>caller</code>）的 <code>ebp</code> 压入栈；</li> <li>给 <code>ebp</code> 赋新值为当前 <code>esp</code>（<code>ebp</code> 为 <code>callee</code> 的栈帧栈底）。</li></ol> <div align="center"><img src="/mit-6.828-lab1-figures/my-func-enter-call.png" width="823px" height="216px" alt="my-func-enter-call"></div> <p>现在就建立好了一个<strong>函数调用的链接关系</strong>（类似链表），根据当前正在执行的函数找到 <code>ebp</code> 的值，其为一个地址，该地址中存储的值为调用者的 <code>ebp</code>：</p> <div class="language-c extra-class"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-c"><code>uint32_<span class="token operator">*</span> ebp <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">read_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 得到 callee 的 ebp</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>ebp<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 这里可以直接这样写，因为最开始给 ebp 初始化的值为 NULL</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment">// 得到返回值和函数调用的参数，进行处理</span>
    ebp <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>ebp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对当前 ebp 存储地址解引用就能够得到存储的 caller 的 ebp</span>
<span class="token punctuation">}</span>
</code></pre></div><div align="center"><img src="/mit-6.828-lab1-figures/stack-frame.png" width="390px" height="378px" alt="stack-frame"></div> <div class="custom-block tip"><p class="custom-block-title">Exercise 9</p> <p>确定栈是怎么初始化的？</p></div> <ol><li>设置断点 <code>b *0x7d71</code>，<code>si</code> 单步执行，对应的源码在 <code>kern/entry.S</code>；</li> <li>对 <code>CR0</code> 进行设置，开启分页机制，然后执行跳转到 <code>relocated</code> 标识处开始运行；</li> <li><strong>将 <code>ebp</code> 设置为 <code>NULL</code></strong>（在进行函数调用栈分析的时候使用 <code>NULL</code> 作为结束标识），在 <code>.data</code> 段设置的栈顶地址给 <code>esp</code>（高地址，<code>0xf0110000</code>，虚拟地址），预留了栈空间。这里定义了两个全局变量 <code>bootstack</code> 和 <code>bootstacktop</code>，<code>bootstack</code> 标识了内存中的一个位置，表示从这里开始的 <code>KSTKSIZE</code> 个字节的区域都是属于这个临时堆栈的（<code>KSTKSIZE</code> 在 <code>inc/memlayout.h</code> 中定义为 32K），<code>bootstacktop</code> 指向这段区域后的第一个字节，由于刚开始堆栈是空的，所以栈顶便是 <code>bootstacktop</code> 所指向的位置【TODO 这里还是有点模糊】。<div class="language-asm6502 extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br></div><pre class="language-asm6502"><code>    relocated:

        # Clear the frame pointer register (EBP)
        # so that once we get into debugging C code,
        # stack backtraces will be terminated properly.
        movl    $<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">0</span>,%ebp           # nuke frame pointer

        # Set the stack pointer
        movl    $(bootstacktop),%esp

        # now to C code
        call    i<span class="token decimalnumber string">386</span>_init

    .data
    # boot stack
       .p<span class="token decimalnumber string">2</span>align    PGSHIFT     # 强制四字节对齐
       .globl      bootstack
    bootstack:
        .space      KSTKSIZE
       .globl      bootstacktop
    bootstacktop:
</code></pre></div></li> <li>调用 <code>i386_init</code> 函数会将下一条指令的地址压入栈（spin，程序不会运行到这里），同时将旧的 <code>ebp</code> 压栈，<code>ebp</code> 指向 <code>esp</code> 的当前位置，这样就设置好了 JOS 调用第一个 C 函数的栈帧。</li></ol> <div class="custom-block tip"><p class="custom-block-title">Exercise 10</p> <p>单步调试查看 <code>backtrace</code> 函数是怎么递归调用的？</p></div> <p><code>mon_backtrace</code> 函数是在 <code>test_backtrace</code> 函数中被调用的：</p> <div align="center"><img src="/mit-6.828-lab1-figures/recursion.png" width="473px" height="273px" alt="recursion"></div> <div class="custom-block tip"><p class="custom-block-title">Exercise 11</p> <p><code>mon_backtrace</code> 功能实现（查看函数调用栈），将 <code>backtrace</code> 功能加入 JOS monitor 中。</p></div> <p>函数参数的入栈顺序是从右到左的，即对于函数参数，最后一个参数先入栈，从右至左，第一个参数最后入栈：</p> <div align="center"><img src="/mit-6.828-lab1-figures/func-args-push-order.png" width="528px" height="292px" alt="func-args-push-order"></div> <p>正在执行的函数有自己的一个 <code>ebp</code> 值，而这个 <code>ebp</code> 作为指针（对应的那块内存）又指向调用该函数的函数的 <code>ebp</code> 的值，即 <strong>callee 的 <code>ebp</code> 作为指针指向 caller 的 <code>ebp</code> 值</strong>。这样我们使用 <code>ebp</code> 不断回溯就能够打印出函数的调用栈了。</p> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">mon_backtrace</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    size_t i<span class="token punctuation">;</span>
    <span class="token keyword">const</span> size_t N <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    uint32_t args<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    uint32_t<span class="token operator">*</span> ebp <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">read_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ebp<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment">// 这个循环终止条件在 ex9 中有解释，movl $0x0,%ebp </span>
        uint32_t eip <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
            args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ebp <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 依次得到各个参数</span>
        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;ebp %08x eip %08x args&quot;</span><span class="token punctuation">,</span> ebp<span class="token punctuation">,</span> eip<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot; %08x&quot;</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        ebp <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>ebp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>JOS 启动后会出现“<code>K&gt;</code>”等待用户输入命令，已经提供了“<code>help</code>”和“<code>kerninfo</code>”两个，这里我们需要添加“<code>backtrace</code>”命令。实现原理：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>  <span class="token comment">// 命令名</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>desc<span class="token punctuation">;</span>  <span class="token comment">// 命令作用，help 时展示</span>
    <span class="token comment">// return -1 to force monitor to exit</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span><span class="token operator">*</span> tf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">Command</span> commands<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;help&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Display this list of commands&quot;</span><span class="token punctuation">,</span> mon_help <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;kerninfo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Display information about the kernel&quot;</span><span class="token punctuation">,</span> mon_kerninfo <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;backtrace&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Display stack backtrace&quot;</span><span class="token punctuation">,</span> mon_backtrace <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在 <code>kern/monitor.c</code> 中定义一个 <code>Command</code> 结构体，包含能够使用的交互命令。主要是第三个参数，表示在 monitor 中键入命令时具体调用的处理函数。</p> <p>当用户在 monitor 中键入命令时是如何进行处理的呢？</p> <ol><li><code>monitor</code> 函数中调用 <code>readline</code> 读入一个命令，<code>buf</code> 指向命令字符串：</li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    buf <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token string">&quot;K&gt; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runcmd</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> tf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li><code>runcmd</code> 处理命令，接受两个参数，第一个就是命令字符串，第二个参数先不做讨论（跳过）。接下来分析 <code>runcmd</code> 函数的实现：（<strong>这个函数实现要好好学习，Redis 中也有这样的命令查表操作</strong>）</li></ol> <ul><li>i) 变量声明与初始化，<code>argv</code> 是一个指针数组，每个数组项指向一个字符串。一个命令分为命令名+命令参数，因此一个命令字符串一般可以分为多个子字符串，<code>argv</code> 的每个数组项指向一个子字符串。<code>argc</code> 代表命令参数的个数：</li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">define</span> WHITESPACE &quot;\t\r\n &quot;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runcmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span>tf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span>MAXARGS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token comment">// Parse the command buffer into whitespace-separated arguments</span>
    argc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    argv<span class="token punctuation">[</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>ii) 在 <code>argv</code> 中保存每一个子字符串，并且将命令字符串中的空格都换成空字符（因为我们在输入命令是，命令名和参数之间、参数和参数之间都是使用空格间隔的），这样处理之后每个子字符串的结尾便都是一个空字符，方便处理；【这个实现需要好好学习】</li></ul> <div class="language-c extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-c"><code>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// gobble whitespace</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf <span class="token operator">&amp;&amp;</span> <span class="token function">strchr</span><span class="token punctuation">(</span>WHITESPACE<span class="token punctuation">,</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">*</span>buf<span class="token operator">++</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 把所有空格字符都置为空字符</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token comment">// 命令结束</span>

        <span class="token comment">// save and scan past next arg</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> MAXARGS<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;Too many arguments (max %d)\n&quot;</span><span class="token punctuation">,</span> MAXARGS<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        argv<span class="token punctuation">[</span>argc<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span><span class="token comment">// 指向子字符串</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strchr</span><span class="token punctuation">(</span>WHITESPACE<span class="token punctuation">,</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span>
            buf<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token comment">// 跳过非空格的字符</span>
    <span class="token punctuation">}</span>
    argv<span class="token punctuation">[</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><div align="center"><img src="/mit-6.828-lab1-figures/runcmd-argv-argc.png" width="565px" height="224px" alt="runcmd-argv-argc"></div> <ul><li>iii) 获取到 <code>argc</code> 和 <code>argv</code> 两个参数后，就可以开始处理命令了。在所有可以执行的命令表中查找对应的函数，调用执行：</li></ul> <div class="language-c extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-c"><code>    <span class="token comment">// Lookup and invoke the command</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">ARRAY_SIZE</span><span class="token punctuation">(</span>commands<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> commands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> tf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;Unknown command '%s'\n&quot;</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">Exercise 12</p> <p>修改 <code>mon_backtrace</code> 使得其能够打印出当前所在的文件、行号和函数（更方便的查看函数调用栈，以及当程序出错时能够更方便的知道哪些函数可能存在 bug）。</p></div> <p>【TODO】符号表理解，这个如何做的，通过查看 <code>debuginfo_eip</code> 函数实现大致知道怎么处理，但为什么是这样的呢？需要理解。</p> <ol><li><code>debuginfo_eip</code> 函数中添加行号查找：</li></ol> <div class="language-c extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br><br></div><pre class="language-c"><code>    <span class="token function">stab_binsearch</span><span class="token punctuation">(</span>stabs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lline<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rline<span class="token punctuation">,</span> N_SLINE<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lline <span class="token operator">&lt;=</span> rline<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        info<span class="token operator">-&gt;</span>eip_line <span class="token operator">=</span> stabs<span class="token punctuation">[</span>lline<span class="token punctuation">]</span><span class="token punctuation">.</span>n_desc<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>在 <code>mon_trace</code> 函数中加入：</li></ol> <div class="language-c extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br><br><br><br></div><pre class="language-c"><code>    <span class="token comment">// 打印额外的信息：所在文件:行数:所在函数</span>
    <span class="token keyword">struct</span> <span class="token class-name">Eipdebuginfo</span> info<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">debuginfo_eip</span><span class="token punctuation">(</span>eip<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;    %s:%d: %.*s+%u\n&quot;</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_file<span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_line<span class="token punctuation">,</span>
            info<span class="token punctuation">.</span>eip_fn_namelen<span class="token punctuation">,</span> info<span class="token punctuation">.</span>eip_fn_name<span class="token punctuation">,</span>
            <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token punctuation">(</span>eip <span class="token operator">-</span> info<span class="token punctuation">.</span>eip_fn_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">&quot;Error happened when reading symbol table\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="总结遇到的问题"><a href="#总结遇到的问题" class="header-anchor">#</a> 总结遇到的问题</h2> <h2 id="主要参考"><a href="#主要参考" class="header-anchor">#</a> 主要参考</h2> <ul><li>主要参考 <a href="http://grid.hust.edu.cn/zyshao/Teaching_Material/OSEngineering/Chapter3.pdf" target="_blank" rel="noopener noreferrer">系统启动与初始化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，为华科的一个老师的课程讲义，现地址已不能访问</li> <li><a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener noreferrer">程序员的自我修养：装载、链接与库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 国人写的一本书，分析的很详细，很有实践意义
<ul><li>第 2 章 编译与链接 2.4 模块拼装——静态链接</li> <li>第 3 章 目标文件里有什么</li> <li>第 4 章 静态链接</li></ul></li> <li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener noreferrer">深入理解计算机系统<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 第 7 章 链接 之前看过好几遍，需要理解</li> <li><a href="https://www.zhihu.com/question/58121772/answer/156287959" target="_blank" rel="noopener noreferrer">Linux 内核应该怎么去学习？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 如陈硕所说，“学习操作系统要注意区分共性与平台特性”</li> <li><a href="https://segmentfault.com/a/1190000007977460" target="_blank" rel="noopener noreferrer">C函数调用过程原理及函数栈帧分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 函数调用和栈帧讲解的很清晰</li> <li><a href="https://pdos.csail.mit.edu/6.828/2018/lec/gdb_slides.pdf" target="_blank" rel="noopener noreferrer">Using the GNU Debugger<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> MIT 6.828 LEC 3 课程讲义</li> <li><a href="https://www.jianshu.com/p/af9d7eee635e" target="_blank" rel="noopener noreferrer">mit6.828-lab1 系统启动<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 简单的过了一遍，之后可以仔细梳理一下</li></ul> <h2 id="附录"><a href="#附录" class="header-anchor">#</a> 附录</h2> <h3 id="附录-1：cprintf-函数的实现"><a href="#附录-1：cprintf-函数的实现" class="header-anchor">#</a> 附录 1：<code>cprintf()</code> 函数的实现</h3> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    va_list ap<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>

    <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cnt <span class="token operator">=</span> <span class="token function">vcprintf</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> ap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">va_end</span><span class="token punctuation">(</span>ap<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里引用 K&amp;R 7.3 变长参数表，省略号表示参数表中的数量和类型是可变的，只能出现在参数表的尾部。如何去处理一个没有名字的参数表呢？头文件 <code>&lt;inc/stdarg.h&gt;</code> 中包含一组宏定义，对如何遍历参数表进行了定义（该头文件的实现因不同的机器而不同，但提供的接口是一致的）</p> <ul><li><strong><code>va_list</code></strong> 类型用于声明一个变量，变量 <code>ap</code>（argument pointer，参数指针）将依次引用各参数，宏 <strong><code>va_start</code></strong> 将 <code>ap</code> 初始化为指向第一个无名参数的指针；</li> <li>在使用 <code>ap</code> 之前，宏 <strong><code>va_start</code></strong> 必须被调用一次；</li> <li>参数表必须至少包括一个有名参数（例如这里的 <code>fmt</code>，它是第一个有名参数，同时也是最后一个有名参数，其后就是无名参数了），宏 <strong><code>va_start</code></strong> 将最后一个有名参数作为起点；</li> <li>每次调用 <strong><code>va_arg</code></strong> 该函数都将返回一个参数，并将 <code>ap</code> 指向下一个参数。宏 <strong><code>va_arg</code></strong> 使用一个类型名来决定返回的对象类型、指针移动的步长；</li> <li>最后，必须在函数返回前调用宏 <strong><code>va_end</code></strong>，以完成一些必要的清理工作。</li></ul> <p>函数的参数实际上都是存放在内存的堆栈中的，<strong>函数参数从右向左依次入栈</strong>（由于内存栈的增长方向是从高地址到低地址，因此参数表前面的有名参数在堆栈的较低地址处），每个参数根据参数类型分配相应大小的栈空间。使用 <strong><code>va_start</code></strong> 宏初始化 <code>ap</code> 之后，<code>ap</code> 就指向第一个可变参数。其后我们就可以通过调用 <strong><code>va_arg</code></strong> 宏一次读取之后的可变参数。</p> <div align="center"><img src="/mit-6.828-lab1-figures/cprintf-ap.png" width="421px" height="288px" alt="cprintf-ap"></div> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">vcprintf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> va_list ap<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">vprintfmt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>putch<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> ap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数 <code>vprintfmt</code> 各参数依次为：</p> <ul><li>函数指针，这里指向 putch，将一个字符输出在屏幕上</li> <li>输出的字符数</li> <li>格式化字符串指针</li> <li>可变参数指针</li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">putch</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>cnt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">cputchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>ch</code> 代表要输出的字符，<code>int</code> 类型变量 32 位，而一个 ASCII 字符只需要 8 位，因此 <code>int</code> 类型的低 8 位表示字符对应的 ASCII 码，而第 8 到 15 位表示输出字符的格式（高 16 位是没有用的）；<code>cnt</code> 指向一个 <code>int</code> 变量，每次往屏幕上输出一个字符就加 1（记录输出字符的个数）</p> <p>为了在屏幕上输出一个字符，依次调用函数 <code>putch -&gt; cputchar -&gt; cons_putc -&gt; lpt_putc -&gt; cga_putc</code></p> <ul><li><code>lpt_putc</code> 做一些输出字符前的准备工作（硬件初始化）</li> <li><code>cga_putc</code> 在屏幕上打印一个字符，接受 <code>int</code> 类型的参数，没有返回值</li></ul> <p>【TODO】需要查看 <code>vprintfmt</code> 是怎么实现的？</p> <h3 id="附录-2：大端和小端"><a href="#附录-2：大端和小端" class="header-anchor">#</a> 附录 2：大端和小端</h3> <blockquote><p>程序员的自我修养——链接、装载与库 附录 A.1  字节序（Byte Order）</p></blockquote> <p>在不同的计算机体系结构中，对于数据（比特、字节、字）等的存储和传输机制有所不同，因而引发了计算机领域中一个潜在但是又重要的问题，即通信双方交流的信息单元应该以怎样的顺序进行传送。目前在各种体系的计算机中通常采用的字节存储机制主要有两种：大端（big-endian）和小端（little-endian）。</p> <p>首先我们需要理解两个概念：<code>MSB</code>（Most Significant Bit/Byte）最重要的位或最重要的字节，对应的，<code>LSB</code>（Least Significant Bit/Byte）最不重要的位或最不重要的字节</p> <p>比如对于一个十六进制整数 <code>0x12345678</code>，<code>0x12</code> 就是 <code>MSB</code>，<code>0x78</code> 就是 <code>LSB</code>。对于 <code>0x78</code> 这个字节，二进制表示为 <code>01111000</code>，最左边的 <code>0</code> 就是 <code>MSB</code>，最右边的 <code>0</code> 就是 <code>LSB</code></p> <ul><li>大端（big-endian）规定：<code>MSB</code> 在存储时放在低地址，在传输时 <code>MSB</code> 放在流的开始；<code>LSB</code> 在存储时放在高地址，在传输时 <code>LSB</code> 放在流的末尾</li> <li>小端（little-endian）规定：<code>MSB</code> 在存储时放在高地址，在传输时 <code>MSB</code> 放在流的末尾；<code>LSB</code> 在存储时放在低地址，在传输时 <code>LSB</code> 放在流的开始</li></ul> <h3 id="附录-3：bootloader-实模式切换到保护模式"><a href="#附录-3：bootloader-实模式切换到保护模式" class="header-anchor">#</a> 附录 3：<code>bootloader</code> 实模式切换到保护模式</h3> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code><span class="token directive keyword">.globl</span> start
start:
  <span class="token directive keyword">.code16</span>                     # Assemble for <span class="token decimalnumber string">16</span>-<span class="token opcode property">bit</span> mode
  <span class="token opcode property">cli</span>                         # Disable interrupts
  <span class="token opcode property">cld</span>                         # String operations increment

  # Set up the important data segment registers (DS, ES, SS).
  xorw    %ax,%ax             # Segment number zero
  movw    %ax,%ds             # -&gt; Data Segment
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment
</code></pre></div><p><code>.code16</code> 表示为 16 位的实模式，<code>cli</code> 表示屏蔽系统中断，<code>cld</code> 置 DF (Direction Flag) 标识位为 0，表示内存地址向高地址增加，之后清空 DS 、ES 、SS 等段寄存器中的内容为 0。</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code>  # Enable <span class="token register variable">A</span><span class="token decimalnumber string">20</span>:
  #   For backwards compatibility with the earliest PCs, physical
  #   address line <span class="token decimalnumber string">20</span> is tied low, so that addresses higher than
  #   <span class="token decimalnumber string">1</span>MB wrap around to zero by default.  This code undoes this.
seta<span class="token decimalnumber string">20</span>.<span class="token decimalnumber string">1</span>:
  # 表示从<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">64</span>端口读取一个字节的数据存入al寄存器中，<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">64</span>作为状态寄存器，
  # 保存了当前状态，判断读取的数据位<span class="token decimalnumber string">1</span>（索引从<span class="token decimalnumber string">0</span>开始）是否等于<span class="token decimalnumber string">1</span>，如果为<span class="token decimalnumber string">1</span>则说明
  # 输入缓冲器满（<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">60</span>/<span class="token decimalnumber string">64</span>口有给<span class="token decimalnumber string">8042</span>的数据）（注：testb测试字节，与操作）
  inb     $<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">64</span>,%al               # Wait for not busy
  testb   $<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">2</span>,%al
  jnz     seta<span class="token decimalnumber string">20</span>.<span class="token decimalnumber string">1</span>

  # 表示写<span class="token decimalnumber string">8042</span>的输出端口P<span class="token decimalnumber string">2</span>，将al的数据写入<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">64</span>端口
  movb    $<span class="token decimalnumber string">0</span>xd<span class="token decimalnumber string">1</span>,%al               # <span class="token decimalnumber string">0</span>xd<span class="token decimalnumber string">1</span> -&gt; port <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">64</span>
  outb    %al,$<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">64</span>

seta<span class="token decimalnumber string">20</span>.<span class="token decimalnumber string">2</span>:
  inb     $<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">64</span>,%al               # Wait for not busy
  testb   $<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">2</span>,%al
  jnz     seta<span class="token decimalnumber string">20</span>.<span class="token decimalnumber string">2</span>

  # 写入P<span class="token decimalnumber string">2</span>，<span class="token register variable">A</span><span class="token decimalnumber string">20</span> Gate置为<span class="token decimalnumber string">1</span>，至此就开通了<span class="token register variable">A</span><span class="token decimalnumber string">20</span>地址线
  movb    $<span class="token decimalnumber string">0</span>xdf,%al               # <span class="token decimalnumber string">0</span>xdf -&gt; port <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">60</span>
  outb    %al,$<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">60</span>
</code></pre></div><p>Intel 推出 x86 架构已近 30 年，刚开始推出的 8086 处理器是一款 16 位的处理器，它标识着 x86 架构的诞生，这种 16 位处理器的数据总线是 16 位的，而地址总线是 20 位的，最多可以寻址 1M 的地址空间。这里有一个为难的问题了，20 根地址总线，所以可以访问的地址是 <code>2^20 = 1MB</code>，但由于是 16 位地址模式，能够表示的地址范围是 0-64KB，为了在 8086 下能够访问 1MB 内存，Intel 采取了分段的模式，即 16 位段基地址，16 位偏移。但这个方式有一个问题，其最大的访问空间为 <code>0xFFFF</code> : <code>0xFFFF = 0x10FFEF = 1MB + 64KB - 16Bytes</code>，8086 只有 20 根地址线，如果访问 <code>100000h - 10FFEFh</code> 之间的内存单元，则必须有第 21 根地址线。因此，设置的机制为，当程序员给出超过 1MB（<code>100000h - 10FFEFh</code>）的地址时，系统不会认为其访问越界而产生异常，而是自动重新从 0 开始计算。之后的 80286 处理器也是 16 位，但地址总线有 24 位，而且从 80286 开始 CPU 演变出两种工作模式：实模式和保护模式。在实模式下，80286 和其后续系统所表现的行为应该和 8086 所表现的完全一样（向后兼容），但是，80286 芯片却存在一个 Bug：如果程序员访问 <code>100000h - 10FFEFh</code> 之间的内存单元，系统会实际访问这块内存，而不是重新从 0 开始。为了解决这个问题，IBM 使用键盘控制器上剩余的一些输出线来管理第 21 根地址线，即 A20 Gate。如果 A20 Gate 被打开, 则当程序员给出 <code>100000h - 10FFEFh</code> 之间的地址时，系统将真正访问这块内存区域；如果 A20 Gate 被禁止，则当程序员给出 <code>100000h - 10FFEFh</code> 之间的地址的时候,系统仍然使用 8086 的方式。</p> <p>从 80286 开始，系统出现了一种新的机制，被称为保护模式。那为什么进入保护模式一定要打开 A20 呢，它对保护模式有什么影响？如果 A20 Gate 被禁止，对于 80286 来说，其地址为 24bit，其地址表示为 <code>EFFFFF</code>；对于 80386 极其随后的 32-bit 芯片来说，其地址表示为 <code>FFEFFFFF</code>。这种表示的意思是，如果 A20 Gate 被禁止，则其第 20-bit 在 CPU 做地址访问的时候是无效的，永远只能被作为 0；如果 A20 Gate 被打开，则其第 20-bit 是有效的，其值既可以为 0，也可以为 1。</p> <p>至此，我们跟踪历史，明晰了当从实模式切换至保护模式时需要将 A20 Gate 打开，上述代码实现了如何打开 A20 地址线。</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code>  # Switch from real to protected mode, using <span class="token register variable">a</span> bootstrap GDT
  # <span class="token opcode property">and</span> segment translation that makes virtual addresses
  # identical to their physical addresses, so that the
  # effective memory map does not change during the switch.
  lgdt    gdtdesc    # 将GDT表的首地址加载到GDTR

# Bootstrap GDT
<span class="token directive keyword">.p2align</span> <span class="token decimalnumber string">2</span>                                # force <span class="token decimalnumber string">4</span> byte alignment
gdt:
  SEG_NULL                                # null seg
  SEG(STA_X|STA_R, <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span>xffffffff)       # code seg
  SEG(STA_W, <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span>xffffffff)             # data seg

gdtdesc:
  <span class="token directive keyword">.word</span>   <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">17</span>                            # sizeof(gdt) - <span class="token decimalnumber string">1</span>
  <span class="token directive keyword">.long</span>   gdt                             # address gdt
</code></pre></div><p>定义 GDT 全局描述符表。首先我们可以看到 GDT 表的存放位置是 4 字节对齐的，也就是说 GDT 表的物理首地址是 4 的倍数。然后 <code>gdt</code> 标识了 3 个 GDT 表项，使用宏 <code>SEG_NULL</code> 和 <code>SEG</code>。</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code>#define SEG_NULL                        \
    <span class="token directive keyword">.word</span> <span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span><span class="token comment">;                         \</span>
    <span class="token directive keyword">.byte</span> <span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span>, <span class="token decimalnumber string">0</span>
#define SEG(type,base,lim)              \
    <span class="token directive keyword">.word</span> (((lim) &gt;&gt; <span class="token decimalnumber string">12</span>) &amp; <span class="token decimalnumber string">0</span>xffff), ((base) &amp; <span class="token decimalnumber string">0</span>xffff)<span class="token comment">;  \</span>
    <span class="token directive keyword">.byte</span> (((base) &gt;&gt; <span class="token decimalnumber string">16</span>) &amp; <span class="token decimalnumber string">0</span>xff), (<span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">90</span> | (type)),     \
        (<span class="token decimalnumber string">0</span>xC<span class="token decimalnumber string">0</span> | (((lim) &gt;&gt; <span class="token decimalnumber string">28</span>) &amp; <span class="token decimalnumber string">0</span>xf)), (((base) &gt;&gt; <span class="token decimalnumber string">24</span>) &amp; <span class="token decimalnumber string">0</span>xff)
</code></pre></div><p><code>SEG_NULL</code> 定义连续 8 个值为 0 的字节，这就表示一个空的 GDT 表项。<code>SEG</code> 宏 <code>type</code> 表示段属性，<code>base</code> 表示段基址，<code>lim</code> 则表示段长的界限，给出这三个参数就可以用这个宏来定义一个 GDT 表项（具体含义略过）。</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code><span class="token directive keyword">.set</span> CR<span class="token decimalnumber string">0</span>_PE_ON,      <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">1</span>         # protected mode enable flag

  movl    %cr<span class="token decimalnumber string">0</span>, %eax
  orl     $CR<span class="token decimalnumber string">0</span>_PE_ON, %eax
  movl    %eax, %cr<span class="token decimalnumber string">0</span>
</code></pre></div><p>使能保护模式，将一个特定的寄存器，系统寄存器 <code>CR0</code> 其第 0 号位置成 1。这里的 <code>orl</code> 是“按位或”操作指令，常用来测试两个操作数是否同时为0，或者用来置位某些位，置位就是将一个位数据设置为 1。</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code><span class="token directive keyword">.set</span> PROT_MODE_CSEG, <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">8</span>         # kernel code segment selector

  # Jump to next instruction, but in <span class="token decimalnumber string">32</span>-<span class="token opcode property">bit</span> code segment.
  # Switches processor into <span class="token decimalnumber string">32</span>-<span class="token opcode property">bit</span> mode.
  ljmp    $PROT_MODE_CSEG, $protcseg
</code></pre></div><p>最后，用一个跳转指令让系统开始使用 32 位的寻址模式。可以看到最后一句长跳转指令实际上是在系统进入保护模式后执行的。于是在这里 <code>$PROT_MODE_CSEG</code> ，代表的是段选择子，从前面的 GDT 表中可以看到基地址是 <code>0x0</code>，而偏移地址是<code>$protcseg</code>，<code>$protcseg</code> 实际上代表的是接下来指令的链接地址，也就是可执行程序在内存中的虚拟地址，只是刚好在这里编译生成的可执行程序 <code>boot</code> 的加载地址与链接地址是一致的，于是 <code>$protcseg</code> 就相当于指令在内存中存放位置的物理地址，所以这个长跳转可以成功的跳转到下一条指令的位置。</p> <div class="language-asm6502 extra-class"><pre class="language-asm6502"><code><span class="token directive keyword">.set</span> PROT_MODE_DSEG, <span class="token decimalnumber string">0</span><span class="token register variable">x</span><span class="token decimalnumber string">10</span>         # kernel data segment selector

  <span class="token directive keyword">.code32</span>                         # Assemble for <span class="token decimalnumber string">32</span>-<span class="token opcode property">bit</span> mode
protcseg:
  # Set up the protected-mode data segment registers
  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS
  movw    %ax, %ss                # -&gt; SS: Stack Segment

  # Set up the stack pointer <span class="token opcode property">and</span> call into C.
  movl    $start, %esp
  call bootmain
</code></pre></div><p>在进入保护模式后，程序在重新对段寄存器进行了初始化后，设置栈的指针并转入 C 函数 <code>bootmain</code> 执行（<code>ebp &lt;- 0</code>、<code>esp &lt;- 0x7c00</code> 栈 从高地址向低地址顺序存放 ）。可以看到，在 <code>call bootmain</code> 之后便是一个无限循环的跳转指令，之所以是无限循环就是这个函数调用永远都不会有返回的可能性，这句程序仅仅只是让整个代码看起来有完整性。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/basic/os/8-io-subsystem.html" class="prev">
        IO 子系统
      </a></span> <span class="next"><a href="/basic/os/mit-6.828-lab2.html">
        Lab 2 - Memory Management
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e709e50c.js" defer></script><script src="/assets/js/2.aed79e5e.js" defer></script><script src="/assets/js/30.113a865b.js" defer></script>
  </body>
</html>
