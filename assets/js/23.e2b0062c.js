(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{270:function(_,v,l){"use strict";l.r(v);var t=l(29),i=Object(t.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h1",{attrs:{id:"页面置换算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法"}},[_._v("#")]),_._v(" 页面置换算法")]),_._v(" "),l("h2",{attrs:{id:"页面置换算法的概念"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法的概念"}},[_._v("#")]),_._v(" 页面置换算法的概念")]),_._v(" "),l("p",[l("strong",[_._v("功能：")])]),_._v(" "),l("p",[_._v("当出现缺页异常，需调入新页面而物理内存已满时，置换算法选择被置换的物理页帧")]),_._v(" "),l("p",[l("strong",[_._v("设计目标：")])]),_._v(" "),l("p",[_._v("尽可能减少页帧的调入调出次数，把未来不再访问或短期内不访问的页帧调出。这与实际运行的程序对存储的访问特征有很大关系（通用置换算法考虑可能得进程访问存储的特征）。如何对未来的情况进行估计呢？")]),_._v(" "),l("p",[_._v("有一些物理页帧被锁定（Frame Locking，pin memory），不能够从物理内存中换出到外存中去")]),_._v(" "),l("ul",[l("li",[_._v("描述必须常驻内存的逻辑页面")]),_._v(" "),l("li",[_._v("操作系统的关键部分")]),_._v(" "),l("li",[_._v("要求响应速度的代码和数据")]),_._v(" "),l("li",[_._v("页表项中的锁定标志位（lock bit）")])]),_._v(" "),l("p",[l("strong",[_._v("置换算法的评价方法：")])]),_._v(" "),l("p",[_._v("记录进程访问内存的页面轨迹，模拟页面置换行为，记录产生缺页的次数。更少的缺页，对应更好的性能")]),_._v(" "),l("p",[l("strong",[_._v("页面置换算法的分类：")])]),_._v(" "),l("ol",[l("li",[_._v("局部页面置换算法：置换页面的选择范围仅限于当前进程占用的物理页面内\n"),l("ul",[l("li",[_._v("最优算法、先进先出算法、最近最久未使用算法")]),_._v(" "),l("li",[_._v("时钟算法、最不常用算法（两种对最近最久未使用算法的近似）")])])]),_._v(" "),l("li",[_._v("全局页面置换算法：置换页面的选择范围是所有可换出的物理页面\n"),l("ul",[l("li",[_._v("工作集算法、缺页率算法")])])])]),_._v(" "),l("h2",{attrs:{id:"局部置换算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#局部置换算法"}},[_._v("#")]),_._v(" 局部置换算法")]),_._v(" "),l("p",[_._v("假定给一个进程的物理页面数已经确定好了")]),_._v(" "),l("h3",{attrs:{id:"最优页面置换算法（opt，optimal）"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#最优页面置换算法（opt，optimal）"}},[_._v("#")]),_._v(" 最优页面置换算法（OPT，optimal）")]),_._v(" "),l("ul",[l("li",[_._v("思路：置换在未来最长时间不访问的页面")]),_._v(" "),l("li",[_._v("实现：缺页时，计算内存中每个逻辑页面的下一次访问时间，选择未来最长时间不放问的页面")]),_._v(" "),l("li",[_._v("特征\n"),l("ul",[l("li",[_._v("缺页最少，是理想情况")]),_._v(" "),l("li",[_._v("实际系统中无法实现")]),_._v(" "),l("li",[_._v("无法预知每个页面在下次访问前的等待时间")]),_._v(" "),l("li",[_._v("可以作为其他置换算法的性能评价依据：在模拟器上运行某个程序并记录每一次的页面访问情况；在第二次运行时使用最优页面置换算法")])])])]),_._v(" "),l("h3",{attrs:{id:"先进先出算法（fifo，first-in-first-out）"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#先进先出算法（fifo，first-in-first-out）"}},[_._v("#")]),_._v(" 先进先出算法（FIFO，First-In First-Out）")]),_._v(" "),l("ul",[l("li",[_._v("思路：选择在内存驻留时间最长的页面进行置换")]),_._v(" "),l("li",[_._v("实现\n"),l("ul",[l("li",[_._v("维护一个记录所有位于内存中的逻辑页面链表")]),_._v(" "),l("li",[_._v("链表元素按驻留内存的时间排序，链首最长，链尾最短")]),_._v(" "),l("li",[_._v("出现缺页时，选择链首页面进行置换，新页面加到链尾")])])]),_._v(" "),l("li",[_._v("特征\n"),l("ul",[l("li",[_._v("实现简单")]),_._v(" "),l("li",[_._v("性能较差，调出的页面可能是经常访问的")]),_._v(" "),l("li",[_._v("进程分配物理页面数增加时，缺页并不一定减少（Belady 现象）")]),_._v(" "),l("li",[_._v("很少单独使用")])])])]),_._v(" "),l("h3",{attrs:{id:"最近最久未使用算法（lru，least-recently-used）"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#最近最久未使用算法（lru，least-recently-used）"}},[_._v("#")]),_._v(" 最近最久未使用算法（LRU，Least Recently Used）")]),_._v(" "),l("ul",[l("li",[_._v("思路：选择最长时间没有被引用的页面进行置换，如某些页面长时间未被访问，则它们在将来还可能会长时间不会被访问")]),_._v(" "),l("li",[_._v("实现\n"),l("ul",[l("li",[_._v("缺页时，计算内存中每个逻辑页面的上一次访问时间")]),_._v(" "),l("li",[_._v("选择上一次使用到当前时间最长的页面")])])]),_._v(" "),l("li",[_._v("特征：最优置换算法的一种近似，开销较大")]),_._v(" "),l("li",[_._v("可能实现：\n"),l("ul",[l("li",[l("ol",[l("li",[_._v("页面链表：系统维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，链表尾节点是最久未使用的页面")])]),_._v(" "),l("ul",[l("li",[_._v("访问内存时，找到相应页面，并把它移到链表首部")]),_._v(" "),l("li",[_._v("缺页时，置换链表尾节点的页面")])])]),_._v(" "),l("li",[l("ol",{attrs:{start:"2"}},[l("li",[_._v("活动页面栈")])]),_._v(" "),l("ul",[l("li",[_._v("访问页面时，将此页号压入栈顶，并栈内相同的页号抽出")]),_._v(" "),l("li",[_._v("缺页时，置换栈底的页面")])])])])])]),_._v(" "),l("h3",{attrs:{id:"时钟页面置换算法（clock）"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#时钟页面置换算法（clock）"}},[_._v("#")]),_._v(" 时钟页面置换算法（Clock）")]),_._v(" "),l("ul",[l("li",[_._v("思路\n"),l("ul",[l("li",[_._v("仅对页面的访问情况进行大致排序")])])]),_._v(" "),l("li",[_._v("数据结构\n"),l("ul",[l("li",[_._v("在页表项中增加访问位，描述页面在过去一段时间内的访问情况")]),_._v(" "),l("li",[_._v("各页面组织成环形链表")]),_._v(" "),l("li",[_._v("指针指向最先调入的页面")])])]),_._v(" "),l("li",[_._v("算法\n"),l("ul",[l("li",[_._v("访问页面时，在页表项记录页面的访问情况")]),_._v(" "),l("li",[_._v("缺页时，从指针处开始顺序查找未被访问的页面进行置换（FIFO）")])])]),_._v(" "),l("li",[_._v("特征\n"),l("ul",[l("li",[_._v("时钟算法是 LRU 和 FIFO 的折中（对过去的访问情况有考虑，但是置换的就是过去一段时间没有访问的页面，不是去找最久未访问的页面）")])])]),_._v(" "),l("li",[_._v("实现：\n"),l("ul",[l("li",[_._v("页面装入内存时，访问位初始化为 0；访问页面（读/写）时，访问位设置为 1")]),_._v(" "),l("li",[_._v("缺页时，从指针当前位置顺序检查环形链表，若访问位为 0，则置换该页；若访问位为 1，则将访问位设置为 0（表示从当前时间点重新开始记录是否访问），并指针移动到下一个页面，直到找到可置换的页面")])])]),_._v(" "),l("li",[_._v("改进的时钟算法\n"),l("ul",[l("li",[_._v("思路是减少修改页的缺页处理开销（如果有修改，则跳过这一页不做置换，系统定期将修改过的页写到外存中去）。")]),_._v(" "),l("li",[_._v("在页表项中增加修改位，并在访问时进行相应修改（如果是读操作，仅修改访问位为1，修改位为 0；如果是写操作，修改位和访问位同时置 1）")]),_._v(" "),l("li",[_._v("缺页时，修改页表项标志位，以跳过有修改的页面")])])])]),_._v(" "),l("div",{attrs:{align:"center"}},[l("img",{attrs:{src:"/os-notes-figures/dirty-reference-bit.png",width:"187px",height:"141px",alt:"dirty-reference-bit"}})]),_._v(" "),l("h3",{attrs:{id:"最不常用算法（lfu，least-frequently-used）"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#最不常用算法（lfu，least-frequently-used）"}},[_._v("#")]),_._v(" 最不常用算法（LFU，Least Frequently Used）")]),_._v(" "),l("ul",[l("li",[_._v("思路：缺页时，置换访问次数最少的页面")]),_._v(" "),l("li",[_._v("实现\n"),l("ul",[l("li",[_._v("每个页面设置一个访问计数")]),_._v(" "),l("li",[_._v("访问页面时，访问计数加 1")]),_._v(" "),l("li",[_._v("缺页时，置换计数最小的页面")])])]),_._v(" "),l("li",[_._v("特征\n"),l("ul",[l("li",[_._v("算法开销大")]),_._v(" "),l("li",[_._v("开始时频繁使用，但以后不使用的页面很难置换（解决办法：计数定期做衰减右移）")])])]),_._v(" "),l("li",[_._v("LRU 和 LFU 的区别\n"),l("ul",[l("li",[_._v("LRU 关注多久未访问，时间越短越好")]),_._v(" "),l("li",[_._v("LFU 关注访问次数，次数越多越好")])])])]),_._v(" "),l("h3",{attrs:{id:"belady-现象"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#belady-现象"}},[_._v("#")]),_._v(" Belady 现象")]),_._v(" "),l("ul",[l("li",[_._v("现象：采用 FIFO 等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象")]),_._v(" "),l("li",[_._v("原因：FIFO 算法的置换特征与进程访问内存的动态特征相矛盾，被算法置换出去的页面并不一定是进程近期不会访问的")]),_._v(" "),l("li",[_._v("思考：哪些置换算法没有 Belady 现象？LRU 没有 Belady 现象")]),_._v(" "),l("li",[_._v("时钟/改进的时钟页面置换算法是否有 Belady 现象？")]),_._v(" "),l("li",[_._v("为什么 LRU 页面置换算法没有 Belady 现象？【思考？】")])]),_._v(" "),l("h3",{attrs:{id:"比较"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#比较"}},[_._v("#")]),_._v(" 比较")]),_._v(" "),l("ul",[l("li",[_._v("LRU 算法和 FIFO 本质上都是先进先出的思想\n"),l("ul",[l("li",[_._v("LRU 根据页面的最近访问时间排序")]),_._v(" "),l("li",[_._v("LRU 在执行过程中需要动态地调整顺序")]),_._v(" "),l("li",[_._v("FIFO 依据页面进入内存的时间排序")]),_._v(" "),l("li",[_._v("FIFO 的页面进入时间是固定不变的")])])]),_._v(" "),l("li",[_._v("LRU 可退化为 FIFO\n"),l("ul",[l("li",[_._v("如页面进入内存后就没有被访问，最近访问时间和进入内存时间是相同的（视频流）")])])]),_._v(" "),l("li",[_._v("LRU 算法性能好，但系统开销较大")]),_._v(" "),l("li",[_._v("FIFO 算法系统开销较小，会发生 Belady 现象")]),_._v(" "),l("li",[_._v("Clock 算法是 LRU 和 FIFO 的折中\n"),l("ul",[l("li",[_._v("访问页面时，不动态调整页面在链表中的顺序，仅做标记")]),_._v(" "),l("li",[_._v("缺页时，再把它移动到链表末尾")])])]),_._v(" "),l("li",[_._v("对于未访问过的页面，Clock 和 LRU 算法的表现一样好")]),_._v(" "),l("li",[_._v("对于被访问过的页面，Clock 算法不能记录准确访问顺序，而 LRU 算法可以")])]),_._v(" "),l("h2",{attrs:{id:"全局页面置换算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#全局页面置换算法"}},[_._v("#")]),_._v(" 全局页面置换算法")]),_._v(" "),l("p",[_._v("局部页面置换算法没有考虑进程访存的差异性（因为分配给进程的页面数确定了）")]),_._v(" "),l("p",[_._v("全局置换算法为进程分配可变数目的物理页面。那分给各个进程多少物理页面呢？进程在不同阶段的内存需求是变化的，这样再不同的阶段分配给进程的内存也需要有所变化。全局置换算法需要确定分配给进程的物理页面数")]),_._v(" "),l("h3",{attrs:{id:"cpu-利用率与并发进程数的关系"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#cpu-利用率与并发进程数的关系"}},[_._v("#")]),_._v(" CPU 利用率与并发进程数的关系")]),_._v(" "),l("p",[_._v("CPU 利用率与并发进程数存在相互促进和制约的关系")]),_._v(" "),l("ul",[l("li",[_._v("进程数少时，提高并发进程数，可提高 CPU 利用率")]),_._v(" "),l("li",[_._v("并发进程导致内存访问增加")]),_._v(" "),l("li",[_._v("并发进程的内存访问会降低访存的局部性特征")]),_._v(" "),l("li",[_._v("局部性特征的下载会导致缺页率上升和 CPU 利用率下降")])]),_._v(" "),l("div",{attrs:{align:"center"}},[l("img",{attrs:{src:"/os-notes-figures/prognum-cpu-utility.png",width:"260px",height:"169px",alt:"prognum-cpu-utility"}})]),_._v(" "),l("h3",{attrs:{id:"工作集置换算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#工作集置换算法"}},[_._v("#")]),_._v(" 工作集置换算法")]),_._v(" "),l("p",[_._v("一个进程当前正在使用的逻辑页面集合，可表示为二元函数 W(t, Δ)")]),_._v(" "),l("ul",[l("li",[_._v("t 是当前的执行时刻")]),_._v(" "),l("li",[_._v("Δ 称为工作集窗口（working-set window），即一个定长的页面访问时间窗口")]),_._v(" "),l("li",[_._v("W(t, Δ) 是指在当前时刻 t 前的 Δ 时间窗口中的所有访问页面所组成的集合")]),_._v(" "),l("li",[_._v("|W(t, Δ)| 指工作集的大小，即页面数目")])]),_._v(" "),l("p",[_._v("一个进程的工作集的大小随着进程执行时间的变化而变化：")]),_._v(" "),l("div",{attrs:{align:"center"}},[l("img",{attrs:{src:"/os-notes-figures/working-set-size.png",width:"357px",height:"183px",alt:"working-set-size"}})]),_._v(" "),l("ol",[l("li",[_._v("进程开始执行后，随着访问新页面逐步建立较稳定的工作集")]),_._v(" "),l("li",[_._v("当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定")]),_._v(" "),l("li",[_._v("局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值")])]),_._v(" "),l("p",[l("strong",[_._v("常驻集：")])]),_._v(" "),l("p",[_._v("在当前时刻，进程实际驻留在内存当中的页面集合")]),_._v(" "),l("p",[l("strong",[_._v("工作集与常驻集的关系：")])]),_._v(" "),l("ul",[l("li",[_._v("工作集是进程在运行过程中的固有性质")]),_._v(" "),l("li",[_._v("常驻集取决于系统分配给进程的物理页面数目和页面置换算法")])]),_._v(" "),l("p",[l("strong",[_._v("缺页率和常驻集的关系：")])]),_._v(" "),l("ul",[l("li",[_._v("如果常驻集包含了工作集，缺页较少")]),_._v(" "),l("li",[_._v("工作集发生剧烈变动（过渡）时，缺页较多")]),_._v(" "),l("li",[_._v("进程常驻集大小达到一定数目后，缺页率也不会明显下降")])]),_._v(" "),l("p",[l("strong",[_._v("工作集置换算法：")])]),_._v(" "),l("ul",[l("li",[_._v("思路：换出不在工作集的页面")]),_._v(" "),l("li",[_._v("窗口大小 𝞽，当前时刻前 𝞽 各内存访问的页引用是工作集，被称为窗口大小")]),_._v(" "),l("li",[_._v("实现方法（开销大）\n"),l("ul",[l("li",[_._v("访存链表：链表用于维护窗口内的访存页面")]),_._v(" "),l("li",[_._v("访存时，换出不在工作集的页面；更新访存链表")]),_._v(" "),l("li",[_._v("缺页时，换入页面；更新访存链表")])])])]),_._v(" "),l("h3",{attrs:{id:"缺页率置换算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#缺页率置换算法"}},[_._v("#")]),_._v(" 缺页率置换算法")]),_._v(" "),l("p",[_._v("根据缺页之间的间隔来调整将哪些页面放到内存中，哪些页面需要被置换出去")]),_._v(" "),l("p",[l("strong",[_._v("缺页率（page fault rate）：")])]),_._v(" "),l("p",[_._v("通常情况下，我们理解的缺页率是缺页的次数和访存次数之间的比值（缺页平均时间间隔的倒数）。影响缺页率的因素有：")]),_._v(" "),l("ol",[l("li",[_._v("页面置换算法")]),_._v(" "),l("li",[_._v("分配给进程的物理页面数")]),_._v(" "),l("li",[_._v("页面大小")]),_._v(" "),l("li",[_._v("程序的编写方法")])]),_._v(" "),l("p",[l("strong",[_._v("缺页率置换算法（PFF，Page Fault Frequency）：")])]),_._v(" "),l("p",[_._v("通过调节常驻集大小，使得每个进程的缺页率保持在一个合理的范围内")]),_._v(" "),l("p",[_._v("![][page-fault-rate]\n")]),l("div",{attrs:{align:"center"}},[l("img",{attrs:{src:"/os-notes-figures/page-fault-rate.png",width:"263px",height:"157px",alt:"page-fault-rate"}})]),l("p"),_._v(" "),l("ol",[l("li",[_._v("若进程缺页率过高，则增加常驻集以分配更多的物理页面")]),_._v(" "),l("li",[_._v("若进程缺页率过低，则减少常驻集以较少它的物理页面数")])]),_._v(" "),l("p",[l("strong",[_._v("实现：")])]),_._v(" "),l("ul",[l("li",[_._v("访存时，设置引用位标志")]),_._v(" "),l("li",[_._v("缺页时，计算从上次缺页时间 t_{last} 到现在 t_{current} 的时间间隔")]),_._v(" "),l("li",[_._v("如果 t_{current} - t_{last} > T，则置换所有在 [t_{current}, t_{last}] 时间内没有被引用的页")]),_._v(" "),l("li",[_._v("如果  t_{current} - t_{last} <= T，则增加缺失页到常驻集中")]),_._v(" "),l("li",[_._v("在工作集算法中，选择需要置换的页面是在访问时，开销比较大；在缺页率算法中，是在产生缺页中断时，会去考察缺页率是过低还是过高，将置换页面的操作放到缺页时来进行处理")])]),_._v(" "),l("h3",{attrs:{id:"抖动（thrashing）"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#抖动（thrashing）"}},[_._v("#")]),_._v(" 抖动（thrashing）")]),_._v(" "),l("p",[_._v("在系统中有多少个并发执行的进程在一起执行，对于系统来说是效率最高的")]),_._v(" "),l("p",[_._v("抖动是由于在系统中执行的进程数目过多，每个进程分配到的物理页面数太少，减少到一定程度，不能包含工作集，因此造成大量缺页，频繁置换，进程运行速度变慢。即随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。")]),_._v(" "),l("p",[_._v("操作系统需要在并发水平和缺页率之间达到一个平衡，选择一个适当的进程数目（调节并发进程数）和进程需要的物理页面数目（置换算法）")]),_._v(" "),l("h3",{attrs:{id:"负载控制"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#负载控制"}},[_._v("#")]),_._v(" 负载控制")]),_._v(" "),l("p",[_._v("通过调节并发进程数（MPL，Multi-Programming Level）来进行系统负载控制")]),_._v(" "),l("ul",[l("li",[_._v("𝞢WSi = 内存大小")]),_._v(" "),l("li",[_._v("平均缺页间隔时间（MTBF，Mean Time Between Page Faults）")]),_._v(" "),l("li",[_._v("缺页异常处理时间（PFST，Page Fault Service Time）")])]),_._v(" "),l("div",{attrs:{align:"center"}},[l("img",{attrs:{src:"/os-notes-figures/load-balance.png",width:"363px",height:"167px",alt:"load-balance"}})]),_._v(" "),l("p",[_._v("目标：就整个系统处于均衡的繁忙状态")])])}),[],!1,null,null,null);v.default=i.exports}}]);